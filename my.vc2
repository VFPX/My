*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="my.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS app AS mybase OF "my.vcx" 		&& The Application namespace
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: execute		&& Executes the specified file
	*</DefinedPropArrayMethod>

	cnamespace = My.App
	Name = "app"
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="warning" type="method" display="Warning"/>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="errormessage" type="property" display="ErrorMessage"/>
		<memberdata name="quietmode" type="property" display="QuietMode"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="execute" type="method" display="Execute"/>
		</VFPData>
	
	PROCEDURE execute		&& Executes the specified file
		lparameters FileName as String, Operation as String, WorkingFolder as String, ;
			OtherParameters as String
		local lcFileName, ;
			lcWorkDir, ;
			lcOperation, ;
			lcParameters, ;
			lnShow
		if empty(FileName)
			return -1
		endif empty(FileName)
		lcFileName   = alltrim(FileName)
		lcWorkDir    = iif(vartype(WorkingFolder) = 'C', alltrim(WorkingFolder), '')
		lcOperation  = iif(vartype(Operation) = 'C' and not empty(Operation), ;
			alltrim(Operation), 'Open')
		lcParameters = iif(vartype(OtherParameters) = 'C', alltrim(OtherParameters), ;
			'')
		lnShow       = iif(upper(lcOperation) = 'Print', 0, 1)
		declare integer ShellExecute in SHELL32.DLL ;
			integer nWinHandle, ;	&& handle of parent window
			string cOperation, ;	&& operation to perform
			string cFileName, ;		&& filename
			string cParameters, ;	&& parameters for the executable
			string cDirectory, ;	&& default directory
			integer nShowWindow		&& window state
		* Returns:			-1: if no filename was passed
		*					2:  bad association
		*					29: failure to load application
		*					30: application is busy 
		*					31: no application association
		*					Values over 32 indicate success and return an instance
		*						handle for the application
		return ShellExecute(0, lcOperation, lcFilename, lcParameters, lcWorkDir, ;
			lnShow)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS audio AS mybase OF "my.vcx" 		&& Handles the computer's sound system
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: play		&& Plays the specified WAV file
		*m: playsystemsound		&& Plays the specified system sound
	*</DefinedPropArrayMethod>

	cnamespace = My.Computer.Audio
	Name = "audio"
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="playsystemsound" type="method" display="PlaySystemSound"/>
		<memberdata name="play" type="method" display="Play"/>
		</VFPData>
	
	PROCEDURE play		&& Plays the specified WAV file
		lparameters SoundFile as String
		#define SND_SYNC       0
		#define SND_ASYNC      1
		#define SND_NODEFAULT  2
		#define SND_LOOP       8
		#define SND_NOSTOP    16
		declare integer sndPlaySound in WinMM.dll string lpszSoundName, integer uFlags
		sndPlaySound(SoundFile, SND_ASYNC)
		
	ENDPROC

	PROCEDURE playsystemsound		&& Plays the specified system sound
		lparameters Sound as String
		local lcSound, ;
			lnSound
		lcSound = iif(vartype(Sound) = 'C', upper(Sound), '')
		do case
			case lcSound = 'QUESTION'
				lnSound = MB_ICONQUESTION
			case lcSound = 'EXCLAMATION'
				lnSound = MB_ICONEXCLAMATION
			case inlist(lcSound, 'INFORMATION', 'ASTERISK')
				lnSound = MB_ICONINFORMATION
			case inlist(lcSound, 'STOP', 'HAND')
				lnSound = MB_ICONSTOP
			otherwise
				lnSound = MB_OK
		endcase
		declare integer MessageBeep in Win32API integer wType
		MessageBeep(lnSound)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS clock AS mybase OF "my.vcx" 		&& Provides properties and methods to handle local and GMT date and time
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: convertgmttolocal		&& Converts the specified GMT date and time to local
		*m: convertlocaltogmt		&& Converts the specified local date and time to GMT
		*m: gmttime_access
		*m: gmttime_assign
		*m: localtime_access
		*m: localtime_assign
		*m: timezonedescription_assign
		*m: timezoneoffset_assign
		*p: gmttime		&& The current date and time as GMT
		*p: localtime		&& The current local date and time
		*p: timezonedescription		&& The description for the current time zone
		*p: timezoneoffset		&& The offset from the current time zone to GMT in seconds
	*</DefinedPropArrayMethod>

	cnamespace = My.Computer.Clock
	gmttime = {}		&& The current date and time as GMT
	localtime = (/:}		&& The current local date and time
	Name = "clock"
	timezonedescription = 		&& The description for the current time zone
	timezoneoffset = 0		&& The offset from the current time zone to GMT in seconds
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="warning" type="method" display="Warning"/>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="errormessage" type="property" display="ErrorMessage"/>
		<memberdata name="quietmode" type="property" display="QuietMode"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="timezonedescription" type="property" display="TimeZoneDescription"/>
		<memberdata name="timezoneoffset" type="property" display="TimeZoneOffset"/>
		<memberdata name="timezonedescription_assign" type="method" display="TimeZoneDescription_Assign"/>
		<memberdata name="timezoneoffset_assign" type="method" display="TimeZoneOffset_Assign"/>
		<memberdata name="localtime" type="property" display="LocalTime"/>
		<memberdata name="localtime_access" type="method" display="LocalTime_Access"/>
		<memberdata name="localtime_assign" type="method" display="LocalTime_Assign"/>
		<memberdata name="gmttime" type="property" display="GMTTime"/>
		<memberdata name="gmttime_access" type="method" display="GMTTime_Access"/>
		<memberdata name="gmttime_assign" type="method" display="GMTTime_Assign"/>
		<memberdata name="convertlocaltogmt" type="method" display="ConvertLocalToGMT"/>
		<memberdata name="convertgmttolocal" type="method" display="ConvertGMTToLocal"/>
		</VFPData>
	
	PROCEDURE convertgmttolocal		&& Converts the specified GMT date and time to local
		lparameters GMTTime as DateTime
		local ltGMTTime, ;
			ltLocalTime
		do case
			case vartype(GMTTime) = 'D'
				ltGMTTime = dtot(GMTTime)
			case vartype(GMTTime) = 'T'
				ltGMTTime = GMTTime
			otherwise
				error 11
				return .NULL.
		endcase
		ltLocalTime = ltGMTTime - This.TimeZoneOffset
		return ltLocalTime
		
	ENDPROC

	PROCEDURE convertlocaltogmt		&& Converts the specified local date and time to GMT
		lparameters LocalTime as DateTime
		local ltLocalTime, ;
			ltGMTTime
		do case
			case vartype(LocalTime) = 'D'
				ltLocalTime = dtot(LocalTime)
			case vartype(LocalTime) = 'T'
				ltLocalTime = LocalTime
			otherwise
				error 11
				return .NULL.
		endcase
		ltGMTTime = ltLocalTime + This.TimeZoneOffset
		return ltGMTTime
		
	ENDPROC

	PROCEDURE gmttime_access
		return This.ConvertLocalToGMT(datetime())
		
	ENDPROC

	PROCEDURE gmttime_assign
		* Throw a "property is read-only" error.
		
		lparameters tuValue
		error cnERR_PROPERTY_READ_ONLY, 'GMTTime'
		
	ENDPROC

	PROCEDURE Init
		local lcTimeZone, ;
			lnID, ;
			lnStandardOffset, ;
			lnDaylightOffset
		
		* Declare the time zone information API function and get the time zone
		* information.
		 
		#define TIME_ZONE_SIZE  172
		declare integer GetTimeZoneInformation in kernel32 ;
			string @lpTimeZoneInformation
		lcTimeZone = replicate(chr(0), TIME_ZONE_SIZE)
		lnID       = GetTimeZoneInformation(@lcTimeZone)
		
		* Determine the standard and daylight time offset.
		 
		lnStandardOffset = ctobin(substr(lcTimeZone,   1, 4), '4RS')
		lnDaylightOffset = ctobin(substr(lcTimeZone, 169, 4), '4RS')
		
		* Determine the total offset based on whether the computer is on daylight time
		* or not. Get the description for the time zone.
		 
		if lnID = 2  && daylight time
			This.TimeZoneDescription = strtran(strconv(substr(lcTimeZone, 89, 64), ;
				6), chr(0), '')
			This.TimeZoneOffset = (lnStandardOffset + lnDaylightOffset) * 60
		else   && standard time
			This.TimeZoneDescription = strtran(strconv(substr(lcTimeZone,  5, 64), ;
				6), chr(0), '')
			This.TimeZoneOffset = lnStandardOffset * 60
		endif lnID = 2
		
	ENDPROC

	PROCEDURE localtime_access
		return datetime()
		
	ENDPROC

	PROCEDURE localtime_assign
		* Throw a "property is read-only" error.
		
		lparameters tuValue
		error cnERR_PROPERTY_READ_ONLY, 'LocalTime'
		
	ENDPROC

	PROCEDURE timezonedescription_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tuValue
		if This.CalledFromThisClass()
			This.TimeZoneDescription = tuValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'TimeZoneDescription'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE timezoneoffset_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tuValue
		if This.CalledFromThisClass()
			This.TimeZoneOffset = tuValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'TimeZoneOffset'
		endif This.CalledFromThisClass()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS computer AS mybase OF "my.vcx" 		&& The Computer namespace
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: computername_access
		*m: computername_assign
		*p: computername		&& The computer name
		*p: owsh		&& A reference to a Windows Scripting Host object
	*</DefinedPropArrayMethod>

	PROTECTED owsh
	cnamespace = My.Computer
	computername = 		&& The computer name
	Name = "computer"
	owsh = .NULL.		&& A reference to a Windows Scripting Host object
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="warning" type="method" display="Warning"/>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="errormessage" type="property" display="ErrorMessage"/>
		<memberdata name="quietmode" type="property" display="QuietMode"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="computername" type="property" display="ComputerName"/>
		<memberdata name="computername_access" type="method" display="ComputerName_Access"/>
		<memberdata name="computername_assign" type="method" display="ComputerName_Assign"/>
		<memberdata name="owsh" type="property" display="oWSH"/>
		</VFPData>
	
	PROCEDURE computername_access
		return This.oWSH.ComputerName
		
	ENDPROC

	PROCEDURE computername_assign
		* Throw a "property is read-only" error.
		
		lparameters tcValue
		error cnERR_PROPERTY_READ_ONLY, 'ComputerName'
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oWSH = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE Init
		* Create a Windows Script Host object.
		
		This.oWSH = createobject('WScript.Network')
		dodefault()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS data AS mybase OF "my.vcx" 		&& Provides data-handling features
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: closeallinstances		&& Closes all open copies of a given table in all datasessions
		*m: closeallinstancesindatasession		&& Closes all open copies of a given table in the specified datasession
		*m: closeopenedcursors		&& Closes any cursors opened since OpenCursorSnapshot was called
		*m: goto		&& Performs a "safe" GOTO
		*m: opencursorsnapshot		&& Takes a snapshot of all open cursors so CloseOpenedCursors knows what to close
		*a: acursors[1,0]		&& An array of open cursors
	*</DefinedPropArrayMethod>

	PROTECTED acursors
	cnamespace = My.Data
	Name = "data"
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="warning" type="method" display="Warning"/>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="errormessage" type="property" display="ErrorMessage"/>
		<memberdata name="quietmode" type="property" display="QuietMode"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="opencursorsnapshot" type="method" display="OpenCursorSnapshot"/>
		<memberdata name="acursors" type="property" display="aCursors"/>
		<memberdata name="closeopenedcursors" type="method" display="CloseOpenedCursors"/>
		<memberdata name="goto" type="method" display="GoTo"/>
		<memberdata name="closeallinstances" type="method" display="CloseAllInstances"/>
		<memberdata name="closeallinstancesindatasession" type="method" display="CloseAllInstancesInDataSession"/>
		</VFPData>
	
	PROCEDURE closeallinstances		&& Closes all open copies of a given table in all datasessions
		lparameters TableName as String
		local lcFile, ;
			laSessions[1], ;
			lnSessions, ;
			lnI
		if vartype(TableName) = 'C' and not empty(TableName)
			with This
				lcFile     = upper(TableName)
				lnSessions = asessions(laSessions)
				for lnI = lnSessions to 1 step -1
					.CloseAllInstancesInDataSession(lcFile, laSessions[lnI])
				next lnI
			endwith
		else
			error cnERR_ARGUMENT_INVALID
		endif vartype(TableName) = 'C' ...
		return
		
	ENDPROC

	PROTECTED PROCEDURE closeallinstancesindatasession		&& Closes all open copies of a given table in the specified datasession
		lparameters tcFile, ;
			tnDataSession
		local lnDataSession, ;
			lcFullPath, ;
			laTables[1], ;
			lnTables, ;
			lcAlias, ;
			lnI, ;
			lcTable
		lnDataSession = set('DATASESSION')
		set datasession to tnDataSession
		lcFullPath = set('FULLPATH')
		set fullpath on
		lnTables = aused(laTables)
		lcAlias  = strtran(juststem(tcFile), ' ', '_')
		for lnI = 1 to lnTables
			lcTable = laTables[lnI, 1]
			if dbf(lcTable) == tcFile or lcTable == tcFile or lcTable == lcAlias
				use in (lcTable)
			endif dbf(lcTable) == tcFile ...
		next lnI
		if lcFullPath = 'OFF'
			set fullpath off
		endif lcFullPath = 'OFF'
		set datasession to lnDataSession
		return
		
	ENDPROC

	PROCEDURE closeopenedcursors		&& Closes any cursors opened since OpenCursorSnapshot was called
		lparameters DataSessionID as Integer
		local lnSessions, ;
			laSessions[1], ;
			lnDataSession, ;
			llError, ;
			llDataSession, ;
			laCursors[1], ;
			lnCursors, ;
			lnI, ;
			lcCursor
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnSessions    = asessions(laSessions)
		lnDataSession = set('DATASESSION')
		do case
			case alen(This.aCursors, 2) = 0
				error 'You must call OpenCursorSnapshot before calling CloseOpenedCursors.'
			case pcount() = 1 and (vartype(DataSessionID) <> 'N' or ;
				not between(DataSessionID, 1, lnSessions))
				llError = .T.
				error cnERR_ARGUMENT_INVALID
			case pcount() = 1 and DataSessionID <> lnDataSession
				set datasession to DataSessionID
				llDataSession = .T.
		endcase
		if not llError
		
		* Get an array of currently open tables and go through them one at a time. If
		* the table wasn't open before, close it.
		
			lnCursors = aused(laCursors)
			for lnI = 1 to lnCursors
				lcCursor = laCursors[lnI, 1]
				if not empty(lcCursor) and ;
					ascan(This.aCursors, lcCursor, -1, -1, 1, 7) = 0
					use in (lcCursor)
				endif not empty(lcCursor) ...
			next lnI
		
		* Restore the former datasession if necessary.
		
			if llDataSession
				set datasession to DataSessionID
			endif llDataSession
		endif not llError
		return
		
	ENDPROC

	PROCEDURE goto		&& Performs a "safe" GOTO
		lparameters RecordNumber as Integer, ;
			Alias as String, ;
			DataSessionID as Integer
		local lnSessions, ;
			laSessions[1], ;
			lnDataSession, ;
			llError, ;
			llDataSession, ;
			lcAlias
		lnSessions    = asessions(laSessions)
		lnDataSession = set('DATASESSION')
		do case
			case vartype(RecordNumber) <> 'N'
				llError = .T.
				error cnERR_ARGUMENT_INVALID
			case pcount() = 3 and (vartype(DataSessionID) <> 'N' or ;
				not between(DataSessionID, 1, lnSessions))
				llError = .T.
				error cnERR_ARGUMENT_INVALID
			case pcount() = 3 and DataSessionID <> lnDataSession
				set datasession to DataSessionID
				llDataSession = .T.
			otherwise
				lnDataSession = set('DATASESSION')
		endcase
		if not llError
		
		* If no alias was passed, use the alias in the current workarea.
		
			do case
				case vartype(Alias) <> 'C' or empty(Alias)
					lcAlias = alias()
				case not used(Alias)
					error cnERR_ALIAS_NOTFOUND, Alias
					lcAlias = ''
				otherwise
					lcAlias = Alias
			endcase
		
		* Move the record pointer.
		
			do case
				case empty(lcAlias)
				case RecordNumber < 0 or between(RecordNumber, 1, reccount(lcAlias))
					go RecordNumber in (lcAlias)
				otherwise
					go bottom in (lcAlias)
					if not eof(lcAlias)
						skip in (lcAlias)
					endif not eof(lcAlias)
			endcase
		
		* Restore the former datasession if necessary.
		
			if llDataSession
				set datasession to DataSessionID
			endif llDataSession
		endif not llError
		return
		
	ENDPROC

	PROCEDURE opencursorsnapshot		&& Takes a snapshot of all open cursors so CloseOpenedCursors knows what to close
		lparameters DataSessionID as Integer
		local lnSessions, ;
			laSessions[1], ;
			llError, ;
			lnDataSession, ;
			lnCursors, ;
			laCursors[1]
		lnSessions = asessions(laSessions)
		do case
			case pcount() = 1 and (vartype(DataSessionID) <> 'N' or ;
				not between(DataSessionID, 1, lnSessions))
				llError = .T.
				error cnERR_ARGUMENT_INVALID
			case pcount() = 1
				lnDataSession = DataSessionID
			otherwise
				lnDataSession = set('DATASESSION')
		endcase
		if not llError
			lnCursors = aused(laCursors, lnDataSession)
			if lnCursors = 0
				dimension This.aCursors[1, 2]
			else
				dimension This.aCursors[lnCursors, 2]
			endif lnCursors = 0
			acopy(laCursors, This.aCursors)
		endif not llError
		
	ENDPROC

ENDDEFINE

DEFINE CLASS filesystem AS mybase OF "my.vcx" 		&& Provides access to file system attributes and methods
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: copydirectory		&& Copies the contents of the specified folder(s)
		*m: copyfile		&& Copies the specified file(s)
		*m: drives_access
		*m: drives_assign
		*m: getdirectoryinfo		&& Returns a Folder object for the specified folder
		*m: getdriveinfo		&& Returns a drive object for the specified drive letter
		*m: getfileinfo		&& Returns a File object for the specified file name
		*m: getlongfilename		&& Returns the long file name for a short (8.3) file name
		*m: getshortfilename		&& Returns the short (8.3) file name for a long file name
		*m: movedirectory		&& Moves the contents of the specified folder(s)
		*m: movefile		&& Moves the specified file(s)
		*p: drives		&& A collection of Drive objects
		*p: ofso		&& A reference to a FileSystemObject object
		*p: owsh		&& A reference to a Windows Script Host object
	*</DefinedPropArrayMethod>

	PROTECTED ofso,owsh
	cnamespace = My.Computer.FileSystem
	drives = .NULL.		&& A collection of Drive objects
	Name = "filesystem"
	ofso = .NULL.		&& A reference to a FileSystemObject object
	owsh = .NULL.		&& A reference to a Windows Script Host object
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="copyfile" type="method" display="CopyFile"/>
		<memberdata name="copydirectory" type="method" display="CopyDirectory"/>
		<memberdata name="getdriveinfo" type="method" display="GetDriveInfo"/>
		<memberdata name="getfileinfo" type="method" display="GetFileInfo"/>
		<memberdata name="getdirectoryinfo" type="method" display="GetDirectoryInfo"/>
		<memberdata name="ofso" type="method" display="oFSO"/>
		<memberdata name="owsh" type="method" display="oWSH"/>
		<memberdata name="getlongfilename" type="method" display="GetLongFileName"/>
		<memberdata name="getshortfilename" type="method" display="GetShortFileName"/>
		<memberdata name="movefile" type="method" display="MoveFile"/>
		<memberdata name="movedirectory" type="method" display="MoveDirectory"/>
		<memberdata name="drives" type="property" display="Drives"/>
		<memberdata name="drives_access" type="method" display="Drives_Access"/>
		<memberdata name="drives_assign" type="method" display="Drives_Assign"/>
		</VFPData>
	
	PROCEDURE copydirectory		&& Copies the contents of the specified folder(s)
		* Copy the contents of the specified folder.
		
		lparameters SourceFolder as String, ;
			DestinationFolder as String, ;
			Overwrite as Logical
		local llReturn
		do case
			case vartype(SourceFolder) <> 'C' or empty(SourceFolder) or ;
				vartype(DestinationFolder) <> 'C' or empty(DestinationFolder)
				error cnERR_ARGUMENT_INVALID
			case not directory(SourceFolder)
				error cnERR_FILE_NOT_FOUND
			otherwise
				This.oFSO.CopyFolder(SourceFolder, DestinationFolder, Overwrite)
				llReturn = directory(DestinationFolder)
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE copyfile		&& Copies the specified file(s)
		* Copy the specified file.
		
		lparameters SourceFile as String, ;
			DestinationFile as String, ;
			Overwrite as Logical
		local llReturn
		do case
			case vartype(SourceFile) <> 'C' or empty(SourceFile) or ;
				vartype(DestinationFile) <> 'C' or empty(DestinationFile)
				error cnERR_ARGUMENT_INVALID
			case not file(SourceFile)
				error cnERR_FILE_NOT_FOUND
			otherwise
				This.oFSO.CopyFile(SourceFile, DestinationFile, Overwrite)
				llReturn = file(DestinationFile)
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oWSH = .NULL.
		This.oFSO = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE drives_access
		return This.oFSO.Drives
		
	ENDPROC

	PROCEDURE drives_assign
		* Trow a "property is read-only" error.
		
		lparameters tuValue
		error cnERR_PROPERTY_READ_ONLY, 'Drives'
		
	ENDPROC

	PROCEDURE getdirectoryinfo		&& Returns a Folder object for the specified folder
		* Return a Folder object for the specified folder.
		
		lparameters FolderName as String
		local luReturn
		luReturn = .NULL.
		do case
			case vartype(FolderName) <> 'C' or empty(FolderName)
				error cnERR_ARGUMENT_INVALID
			case not directory(FolderName)
				error cnERR_FILE_NOT_FOUND
			otherwise
				luReturn = This.oFSO.GetFolder(FolderName)
		endcase
		return luReturn
		
	ENDPROC

	PROCEDURE getdriveinfo		&& Returns a drive object for the specified drive letter
		* Return a Drive object for the specified drive.
		
		lparameters DriveLetter as String
		local luReturn, ;
			lcDrive, ;
			loException, ;
			llError
		luReturn = .NULL.
		if vartype(DriveLetter) = 'C' and not empty(DriveLetter)
			if right(DriveLetter, 1) = ':'
				lcDrive = left(DriveLetter, 1)
			else
				lcDrive = DriveLetter
			endif right(DriveLetter, 1) = ':'
			try
				luReturn = This.oFSO.GetDrive(lcDrive)
			catch to loException
				llError = .T.
			endtry
			if llError
				error cnERR_INVALID_PATH_OR_FILE
			endif llError
		else
			error cnERR_ARGUMENT_INVALID
		endif vartype(DriveLetter) = 'C' ...
		return luReturn
		
	ENDPROC

	PROCEDURE getfileinfo		&& Returns a File object for the specified file name
		* Return a File object for the specified file.
		
		lparameters FileName as String
		local luReturn
		luReturn = .NULL.
		do case
			case vartype(FileName) <> 'C' or empty(FileName)
				error cnERR_ARGUMENT_INVALID
			case not file(FileName)
				error cnERR_FILE_NOT_FOUND
			otherwise
				luReturn = This.oFSO.GetFile(FileName)
		endcase
		return luReturn
		
	ENDPROC

	PROCEDURE getlongfilename		&& Returns the long file name for a short (8.3) file name
		lparameters FileName as String
		local lcFile, ;
			lnLength, ;
			lcBuffer
		if vartype(FileName) = 'C' and not empty(FileName)
			declare integer GetLongPathName in Win32API ;
				string @lpszShortPath, string @lpszLongPath, integer cchBuffer
			lcFile   = FileName + ccNULL
			lnLength = 260
			lcBuffer = space(lnLength)
			GetLongPathName(@lcFile, @lcBuffer, lnLength)
			lcFile = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
		else
			error cnERR_ARGUMENT_INVALID
		endif vartype(FileName) = 'C' ...
		return lcFile
		
	ENDPROC

	PROCEDURE getshortfilename		&& Returns the short (8.3) file name for a long file name
		lparameters FileName as String
		local lcFile, ;
			lnLength, ;
			lcBuffer
		if vartype(FileName) = 'C' and not empty(FileName)
			declare integer GetShortPathName in Win32API ;
				string @lpszLongPath, string @lpszShortPath, integer cchBuffer
			lcFile   = FileName + ccNULL
			lnLength = 260
			lcBuffer = space(lnLength)
			GetShortPathName(@lcFile, @lcBuffer, lnLength)
			lcFile = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
		else
			error cnERR_ARGUMENT_INVALID
		endif vartype(FileName) = 'C' ...
		return lcFile
		
	ENDPROC

	PROCEDURE Init
		* Create instances of the Windows Script Host and File System Object.
		
		This.oWSH = createobject('WScript.Shell')
		This.oFSO = createobject('Scripting.FileSystemObject')
		dodefault()
		
	ENDPROC

	PROCEDURE movedirectory		&& Moves the contents of the specified folder(s)
		* Move the contents of the specified folder.
		
		lparameters SourceFolder as String, ;
			DestinationFolder as String
		local llReturn
		do case
			case vartype(SourceFolder) <> 'C' or empty(SourceFolder) or ;
				vartype(DestinationFolder) <> 'C' or empty(DestinationFolder)
				error cnERR_ARGUMENT_INVALID
			case not directory(SourceFolder)
				error cnERR_FILE_NOT_FOUND
			otherwise
				try
					This.oFSO.MoveFolder(SourceFolder, DestinationFolder)
					llReturn = directory(DestinationFolder)
				catch to loException
				endtry
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE movefile		&& Moves the specified file(s)
		* Move the specified file.
		
		lparameters SourceFile as String, ;
			DestinationFile as String
		local llReturn
		do case
			case vartype(SourceFile) <> 'C' or empty(SourceFile) or ;
				vartype(DestinationFile) <> 'C' or empty(DestinationFile)
				error cnERR_ARGUMENT_INVALID
			case not file(SourceFile)
				error cnERR_FILE_NOT_FOUND
			otherwise
				This.oFSO.MoveFile(SourceFile, DestinationFile)
				llReturn = file(DestinationFile)
		endcase
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS info AS mybase OF "my.vcx" 		&& Contains application-specific properties
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: directorypath_access
		*m: directorypath_assign
		*m: getapplicationinformation		&& Gets information about the specified application
		*m: getcurrentapplicationinformation		&& Gets information about the current application
		*p: comments		&& The application comments
		*p: companyname		&& The company name
		*p: copyright		&& The copyright
		*p: description		&& The application description
		*p: directorypath		&& The directory the application is running from
		*p: internalname		&& The internal name of the application
		*p: language		&& The language
		*p: oleselfregister		&& .T. if the EXE is self-registering
		*p: originalfilename		&& The original file name
		*p: privatebuild		&& The private build
		*p: productname		&& The product name
		*p: productversion		&& The product version
		*p: specialbuild		&& The special build
		*p: trademarks		&& The trademarks
		*p: translationcode		&& The translation code
		*p: version		&& The application version number
	*</DefinedPropArrayMethod>

	cnamespace = My.App.ApplicationInfo
	comments = 		&& The application comments
	companyname = 		&& The company name
	copyright = 		&& The copyright
	description = 		&& The application description
	directorypath = 		&& The directory the application is running from
	internalname = 		&& The internal name of the application
	language = 		&& The language
	Name = "info"
	oleselfregister = 		&& .T. if the EXE is self-registering
	originalfilename = 		&& The original file name
	privatebuild = 		&& The private build
	productname = 		&& The product name
	productversion = 		&& The product version
	specialbuild = 		&& The special build
	trademarks = 		&& The trademarks
	translationcode = 		&& The translation code
	version = 		&& The application version number
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="getapplicationinformation" type="method" display="GetApplicationInformation"/>
		<memberdata name="getcurrentapplicationinformation" type="method" display="GetCurrentApplicationInformation"/>
		<memberdata name="comments" type="property" display="Comments"/>
		<memberdata name="companyname" type="property" display="CompanyName"/>
		<memberdata name="copyright" type="property" display="Copyright"/>
		<memberdata name="description" type="property" display="Description"/>
		<memberdata name="internalname" type="property" display="InternalName"/>
		<memberdata name="version" type="property" display="Version"/>
		<memberdata name="trademarks" type="property" display="Trademarks"/>
		<memberdata name="originalfilename" type="property" display="OriginalFileName"/>
		<memberdata name="privatebuild" type="property" display="PrivateBuild"/>
		<memberdata name="productversion" type="property" display="ProductVersion"/>
		<memberdata name="specialbuild" type="property" display="SpecialBuild"/>
		<memberdata name="oleselfregister" type="property" display="OLESelfRegister"/>
		<memberdata name="language" type="property" display="Language"/>
		<memberdata name="translationcode" type="property" display="TranslationCode"/>
		<memberdata name="productname" type="property" display="ProductName"/>
		<memberdata name="directorypath" type="property" display="DirectoryPath"/>
		<memberdata name="directorypath_access" type="property" display="DirectoryPath_Access"/>
		<memberdata name="directorypath_assign" type="property" display="DirectoryPath_Assign"/>
		</VFPData>
	
	PROCEDURE directorypath_access
		local lcProgram, ;
			lcPath, ;
			loFSO, ;
			loFolder
		with This
			do case
		
		* We already have it.
		
				case not empty(.DirectoryPath)
		
		* We're running in development mode, so get the path of the running program.
		* Note this is returned in upper-case, so use the Scripting.FileSystemObject to
		* get the correct case.
		
				case version(2) = 2
					lcProgram = sys(16)
					lcPath    = justpath(lcProgram)
					if atc('PROCEDURE', lcPath) > 0
						lcPath = substr(lcPath, rat(':', lcPath) - 1)
					endif atc('PROCEDURE', lcPath) > 0
					loFSO          = createobject('Scripting.FileSystemObject')
					loFolder       = loFSO.GetFolder(addbs(lcPath))
					.DirectoryPath = loFolder.Path
		
		* We're running in the runtime.
		
				otherwise
					.DirectoryPath = addbs(justpath(_vfp.ServerName))
			endcase
		endwith
		return This.DirectoryPath
		
	ENDPROC

	PROCEDURE directorypath_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.DirectoryPath = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'DirectoryPath'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE getapplicationinformation		&& Gets information about the specified application
		lparameters EXEPath as String
		local laFileInfo[1], ;
			lnElements
		with This
		
		* Ensure a filename was specified and that the file exists.
		
			do case
				case vartype(EXEPath) <> 'C' or empty(EXEPath)
					error cnERR_ARGUMENT_INVALID
				case not file(EXEPath)
					error cnERR_FILE_NOT_FOUND
		
		* Get the version information.
		
				otherwise
					lnElements = agetfileversion(laFileInfo, EXEPath)
					if lnElements > 0
						.Comment          = laFileInfo[ 1]
						.CompanyName      = laFileInfo[ 2]
						.Description      = laFileInfo[ 3]
						.Version          = laFileInfo[ 4]
						.InternalName     = laFileInfo[ 5]
						.Copyright        = laFileInfo[ 6]
						.Trademarks       = laFileInfo[ 7]
						.OriginalFileName = laFileInfo[ 8]
						.PrivateBuild     = laFileInfo[ 9]
						.ProductName      = laFileInfo[10]
						.ProductVersion   = laFileInfo[11]
						.SpecialBuild     = laFileInfo[12]
						.OLESelfRegister  = not empty(laFileInfo[13])
						.Language         = laFileInfo[14]
						.TranslationCode  = laFileInfo[15]
					else
						store '' to .Comment, .CompanyName, .Description, .Version, ;
							.InternalName, .Copyright, .Trademarks, ;
							.OriginalFileName, .PrivateBuild, .ProductName, ;
							.ProductVersion, .SpecialBuild, .Language, .TranslationCode
						.OLESelfRegister = .F.
					endif lnElements > 0
			endcase
		endwith
		
	ENDPROC

	PROCEDURE getcurrentapplicationinformation		&& Gets information about the current application
		local lcEXE
		if version(2) = 2
			lcEXE = sys(16)
			if atc('PROCEDURE', lcEXE) > 0
				lcEXE = substr(lcEXE, rat(':', lcEXE) - 1)
			endif atc('PROCEDURE', lcEXE) > 0
		else
			lcEXE = _vfp.ServerName
		endif version(2) = 2
		This.GetApplicationInformation(lcEXE)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS my AS mybase OF "my.vcx" 		&& The My namespace
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	cnamespace = My
	Name = "my"

ENDDEFINE

DEFINE CLASS mybase AS custom 		&& The base class for My namespace classes
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: addmembers		&& Adds the member objects specified in the My table
		*m: calledfromthisclass		&& Determines if a method was called from another method in this class or not
		*m: openmytable		&& Opens the My table
		*m: warning		&& Gives a warning message
		*p: builder		&& The builder to use
		*p: ccaption		&& The title for any MESSAGEBOX dialogs
		*p: cnamespace		&& The name space for this object
		*p: errormessage		&& The text of any error that occurred
		*p: quietmode		&& .T. if we should not display any error messages
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED AddObject,AddProperty,BaseClass,Class,ClassLibrary,CloneObject,Comment,ControlCount,Controls,Destroy,Error,Height,HelpContextID,Init,NewObject,Objects,ParentClass,Picture,RemoveObject,ResetToDefault,SaveAsClass,ShowWhatsThis,Tag,WhatsThisHelpID,Width,WriteExpression,WriteMethod
	builder = My.vcx,MyBuilderForm		&& The builder to use
	ccaption = My Framework		&& The title for any MESSAGEBOX dialogs
	cnamespace = 		&& The name space for this object
	errormessage = 		&& The text of any error that occurred
	Name = "mybase"
	quietmode = .F.		&& .T. if we should not display any error messages
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="warning" type="method" display="Warning"/>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="errormessage" type="property" display="ErrorMessage"/>
		<memberdata name="quietmode" type="property" display="QuietMode"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROTECTED PROCEDURE addmembers		&& Adds the member objects specified in the My table
		* Add all member objects registered in the My table.
		
		local lnSelect, ;
			lcNameSpace, ;
			lnLen, ;
			lcCursor, ;
			lcMember, ;
			lcLibrary
		
		* Create a cursor of all objects in this namespace.
		
		lnSelect    = select()
		lcNameSpace = upper(This.cNameSpace) + '.'
		lnLen       = len(lcNameSpace) + 1
		lcCursor    = sys(2015)
		select * from __MY where upper(MEMBER) like (lcNameSpace + '%') and ;
			not empty(CLASS) and not deleted() into cursor (lcCursor)
		
		* Go through the members, adding any that are directly within this namespace
		* (for example, if this is "My", we'll add "My.Computers" but not
		* "My.Computers.Audio").
		
		scan
			lcMember  = alltrim(substr(MEMBER, lnLen))
			lcLibrary = fullpath(alltrim(LIBRARY), This.ClassLibrary)
			if at('.', lcMember) = 0 and file(lcLibrary)
				This.NewObject(lcMember, alltrim(CLASS), lcLibrary)
			endif at('.', lcMember) = 0 ...
		endscan
		use
		select (lnSelect)
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Determines if a method was called from another method in this class or not
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE Destroy
		* Close the My table.
		
		use in select('__MY')
		
	ENDPROC

	PROTECTED PROCEDURE Init
		local llReturn
		with This
		
		* Set our QuietMode flag based on whether we're in development mode or not.
		
			.QuietMode = version(2) = 0
		
		* Open the My table. If we succeeded, add all members registered in it.
		
			llReturn = .OpenMyTable()
			if llReturn
				.AddMembers()
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE openmytable		&& Opens the My table
		* Open the My table and return whether we succeeded or not.
		
		local lcDir, ;
			lcTable, ;
			llReturn, ;
			loException as Exception
		lcDir   = sys(16)
		lcDir   = addbs(justpath(substr(lcDir, at(' ', lcDir, 2) + 1)))
		lcTable = lcDir + 'My.DBF'
		if used('__MY')
			llReturn = .T.
		else
			try
				use (lcTable) again shared order MEMBER alias __MY in 0
				llReturn = .T.
			catch to loException
				This.Warning('Cannot open ' + lcTable + '. The error message is:' + ;
					ccCR + ccCR + loException.Message)
				llReturn = .F.
			endtry
		endif used('__MY')
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE warning		&& Gives a warning message
		* Display a warning message.
		
		lparameters tcMessage
		if not This.QuietMode
			messagebox(tcMessage, MB_ICONEXCLAMATION, This.cCaption)
		endif not This.QuietMode
		This.ErrorMessage = tcMessage
		
	ENDPROC

ENDDEFINE

DEFINE CLASS mybuilderform AS form 		&& The builder for My namespace classes
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpMembers" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oTree" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oImageList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNameSpace" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNameSpace" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTip" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtTip" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMembers" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNameSpaceDescrip" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtNameSpaceDescrip" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrBuilder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblScript" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtScript" UniqueID="" Timestamp="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: getobjectreference		&& Puts a reference to the object being edited into oObject
		*m: loadtree		&& Loads the TreeView with the members for the object
		*m: openmytable		&& Opens the My table
		*m: save		&& Saves the changes the user made
		*p: cdescription		&& The description for the namespace
		*p: cnamespace		&& The namespace for the class
		*p: lautorelease		&& .T. if we're supposed to auto-release
		*p: lautoshow		&& .T. if we're supposed to be displayed
		*p: oobject		&& A reference to the object being edited
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	BindControls = .F.
	Caption = "My Registration Editor"
	cdescription = 		&& The description for the namespace
	cnamespace = 		&& The namespace for the class
	DataSession = 2
	DoCreate = .T.
	FontName = "Tahoma"
	FontSize = 8
	Height = 514
	lautorelease = .F.		&& .T. if we're supposed to auto-release
	lautoshow = .T.		&& .T. if we're supposed to be displayed
	MaxButton = .F.
	MinButton = .F.
	MinHeight = 450
	MinWidth = 350
	Name = "mybuilderform"
	oobject = .NULL.		&& A reference to the object being edited
	ShowTips = .T.
	Width = 514
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="loadtree" type="method" display="LoadTree"/>
		<memberdata name="oobject" type="property" display="oObject"/>
		<memberdata name="getobjectreference" type="method" display="GetObjectReference"/>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="save" type="method" display="Save"/>
		<memberdata name="cdescription" type="property" display="cDescription"/>
		<memberdata name="lautoshow" type="property" display="lAutoShow"/>
		<memberdata name="lautorelease" type="property" display="lAutoRelease"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Anchor = 12, ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 430, ;
		Name = "cmdCancel", ;
		TabIndex = 15, ;
		Top = 484, ;
		Width = 75
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS commandbutton WITH ;
		Anchor = 12, ;
		Caption = "OK", ;
		Default = .F., ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 350, ;
		Name = "cmdOK", ;
		TabIndex = 14, ;
		Top = 484, ;
		Width = 75
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'edtDescription' AS editbox WITH ;
		Anchor = 40, ;
		ControlSource = "__MyCursor.Descrip", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 55, ;
		Left = 260, ;
		Name = "edtDescription", ;
		TabIndex = 9, ;
		ToolTipText = "Specify the description for this member", ;
		Top = 125, ;
		Width = 235
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'edtList' AS editbox WITH ;
		Anchor = 105, ;
		ControlSource = "__MyCursor.List", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 85, ;
		Left = 260, ;
		Name = "edtList", ;
		TabIndex = 13, ;
		ToolTipText = "If the method accepts an enumerated parameter, specify the values and description for the values as comma-delimited pairs on individual lines", ;
		Top = 275, ;
		Width = 235
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'edtNameSpaceDescrip' AS editbox WITH ;
		Anchor = 10, ;
		ControlSource = "Thisform.cDescription", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 50, ;
		Left = 76, ;
		Name = "edtNameSpaceDescrip", ;
		TabIndex = 4, ;
		Top = 30, ;
		Width = 430
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'edtScript' AS editbox WITH ;
		Anchor = 120, ;
		ControlSource = "__MyCursor.Script", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 85, ;
		Left = 260, ;
		Name = "edtScript", ;
		TabIndex = 13, ;
		ToolTipText = "Specify code to execute when IntelliSense fires for this member", ;
		Top = 380, ;
		Width = 235
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'edtTip' AS editbox WITH ;
		Anchor = 40, ;
		ControlSource = "__MyCursor.Tip", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 55, ;
		Left = 260, ;
		Name = "edtTip", ;
		TabIndex = 11, ;
		ToolTipText = "Specify the signature for this method (e.g. MethodName(Parameter1 as String) as Boolean)", ;
		Top = 200, ;
		Width = 235
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'lblDescription' AS label WITH ;
		Anchor = 40, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Description", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 260, ;
		Name = "lblDescription", ;
		TabIndex = 8, ;
		ToolTipText = "Specify the description for this member", ;
		Top = 110, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblList' AS label WITH ;
		Anchor = 40, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Enumerated Parameter List", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 260, ;
		Name = "lblList", ;
		TabIndex = 12, ;
		ToolTipText = "If the method accepts an enumerated parameter, specify the values and description for the values as comma-delimited pairs on individial lines", ;
		Top = 260, ;
		Width = 132
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblMembers' AS label WITH ;
		AutoSize = .T., ;
		Caption = " Members ", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 21, ;
		Name = "lblMembers", ;
		Style = 3, ;
		TabIndex = 5, ;
		Top = 87, ;
		Width = 51
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblNameSpace' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Namespace", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 7, ;
		Name = "lblNameSpace", ;
		TabIndex = 1, ;
		Top = 9, ;
		Width = 57
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblNameSpaceDescrip' AS label WITH ;
		Anchor = 40, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Description", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblNameSpaceDescrip", ;
		TabIndex = 3, ;
		Top = 30, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblScript' AS label WITH ;
		Anchor = 104, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Script", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 260, ;
		Name = "lblScript", ;
		TabIndex = 12, ;
		ToolTipText = "If the method accepts an enumerated parameter, specify the values and description for the values as comma-delimited pairs on individial lines", ;
		Top = 365, ;
		Width = 29
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblTip' AS label WITH ;
		Anchor = 40, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Method Signature", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 15, ;
		Left = 260, ;
		Name = "lblTip", ;
		TabIndex = 10, ;
		ToolTipText = "Specify the signature for this method (e.g. MethodName(Parameter1 as String) as Boolean)", ;
		Top = 185, ;
		Width = 87
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'oImageList' AS olecontrol WITH ;
		Height = 100, ;
		Left = 211, ;
		Name = "oImageList", ;
		Top = 109, ;
		Width = 100
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\system32\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBwDWVJjMgBAwAAAEABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXAAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAIAAAD+/////v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8jfyQskYXREbFqAMDwKDYoIUM0EggAAADtAwAA7QMAAIB+4eYAAAYAIAAAAAAAAADAwMAA//8AAAHvzasAAAUAXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAD/////BQAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==" />

	ADD OBJECT 'oTree' AS olecontrol WITH ;
		Anchor = 135, ;
		Height = 355, ;
		Left = 15, ;
		Name = "oTree", ;
		TabIndex = 6, ;
		Top = 110, ;
		Width = 231
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\system32\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7///8EAAAA/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHD7DGVJjMgBAwAAAEACAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiwAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAO8AAAAAAAAABwAAAAIAAAD+////BAAAAAUAAAAGAAAA/v///wgAAAD+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAMDwKDYoIUM0EggAAADgFwAAsSQAALE8wWoBAAYAIgAAAPwANgDtAwAASQBQAFEsvAAB782rXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTFvAGsAXABEAGEAdABhAFwAYQBkAGQAcgBlAHMAcwAgAGIAbwABAACADgAAAEhpZGVTZWxlY3Rpb24ABQAAAEwBAAAADAAAAEluZGVudGF0aW9uABEAAABODQAAAAcAAAAAAAAAAABDQAoAAABMYWJlbEVkaXQACQAAAEkKAAAAAQAAAA0AAABNb3VzZVBvaW50ZXIACQAAAEkKAAAAAAAAAA4AAABQYXRoU2VwYXJhdG9yAAoAAABIAAAAAAEAAABcDAAAAE9MRURyYWdNb2RlAAkAAABJCgAAAAAAAAAMAAAAT0xFRHJvcE1vZGUACQAAAEkKAAAAAAAAAAsAAABDaGVja2JveGVzAAUAAABMAQAAAAD+kQAAAAAAAPATAQAAAAAAAAAFACAuvAAGAGMAAAAAAAUAAIBk6RIAAQAAAFwAH97svQEABQCp6RIAA1LjC5GPzhGd4wCqAEu4UQEAAACQAURCAQAGVGFob21hhmj3AwAo5TMFoKvCAICAAACAgAAAAAAAAMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgIAAAAAAAAD///8AAAAAAP///wD///8AAAAAAP///wD///8A////AP///wD///8A////AP///wAAAAAAAP//AAD//wAAgIAAAAAAAP///wCAgIAAgICAAICAgAAAAAAAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8AAAAAAICAAAAAAAAA////AP///wAAAAAA////AP///wD///8A////AP///wD///8A////AP///wAAAAAAAP//AAD//wAAgIAAAAAAAP///wCAgIAAgICAAAAAAADAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP///wAAAAAA////AAAAAACAgAAAgIAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AAAAAAAA//8AAP//AACAgAAAAAAA////AP///wCAgIAAAAAAAMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgIAAAAAAAAD///8AAAAAAP///wD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" />

	ADD OBJECT 'shpMembers' AS shape WITH ;
		Anchor = 15, ;
		BackStyle = 0, ;
		Height = 381, ;
		Left = 6, ;
		Name = "shpMembers", ;
		Style = 3, ;
		Top = 94, ;
		Width = 500
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'tmrBuilder' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 1000, ;
		Left = 225, ;
		Name = "tmrBuilder", ;
		Top = 155, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'txtNameSpace' AS textbox WITH ;
		Anchor = 10, ;
		ControlSource = "Thisform.cNameSpace", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Format = "T", ;
		Height = 23, ;
		Left = 77, ;
		Name = "txtNameSpace", ;
		TabIndex = 2, ;
		Top = 6, ;
		Width = 430
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Destroy
		* Nuke member objects and close cursors.
		
		This.oObject = .NULL.
		use in select('__MY')
		use in select('__MYCURSOR')
		
	ENDPROC

	PROTECTED PROCEDURE getobjectreference		&& Puts a reference to the object being edited into oObject
		local laObjects[1], ;
			lnObjects
		lnObjects = aselobj(laObjects)
		if lnObjects = 0
			lnObjects = aselobj(laObjects, 3)
		endif lnObjects = 0
		if lnObjects > 0
			This.oObject = laObjects[1]
			This.tmrBuilder.Enabled = .T.
		endif lnObjects > 0
		return vartype(This.oObject) = 'O'
		
	ENDPROC

	PROCEDURE Init
		* Turn on debugging. Do this before declaring variables since that seems to
		* mess them up.
		
		sys(2030, 1)
		local llError, ;
			lnLen, ;
			lcPath, ;
			llReturn
		with This
		
		* Get a reference to the selected object and open the My table.
		
			do case
				case not .GetObjectReference()
					messagebox(ccERR_NO_OBJECT_SELECTED_LOC, MB_ICONEXCLAMATION, ;
						.Caption)
					llError = .T.
				case .OpenMyTable() 
		
		* If the object has a cNameSpace property, use it. Otherwise, assume the
		* namespace is "My." plus the class name.
		
					if pemstatus(.oObject, 'cNameSpace', 5) and ;
						not empty(.oObject.cNameSpace)
						.cNameSpace = .oObject.cNameSpace
					else
						.cNameSpace = 'My.' + proper(.oObject.Class)
					endif pemstatus(.oObject, 'cNameSpace', 5) ...
		
		* Fill a cursor with any records already registered.
		
					lnLen = len(.cNameSpace) + 2
					select * from __MY ;
						where upper(MEMBER) = upper(.cNameSpace) and ;
							at('.', alltrim(substr(MEMBER, lnLen))) = 0 and ;
							(upper(MEMBER) = upper(.cNameSpace) + ' ' or ;
								TYPE <> 'C') and ;
							not deleted() ;
						into cursor __MYCURSOR readwrite
					index on upper(MEMBER) tag MEMBER
		
		* Add a record for the class if there isn't one.
		
					locate for TYPE = 'C'
					if found()
						.cDescription = DESCRIP
					else
						lcPath = sys(2014, sys(1271, .oObject), .ClassLibrary)
						insert into __MYCURSOR (MEMBER, TYPE, CLASS, LIBRARY) ;
							values (.cNameSpace, 'C', .oObject.Class, lcPath)
					endif found()
		
		* Load the TreeView, select the first node, and turn on data binding.
		
					.LoadTree()
					.oTree.NodeClick(.oTree.Nodes(1))
					.BindControls = .T.
				otherwise
					messagebox(ccERR_COULD_NOT_OPEN_MY_LOC, MB_ICONEXCLAMATION, ;
						.Caption)
					llError = .T.
			endcase
		endwith
		
		* If we have a problem, bug out now.
		
		llReturn = .T.
		do case
			case not llError
			case program(program(-1) - 1) = 'DOBUILDER'
				This.lAutoShow    = .F.
				This.lAutoRelease = .T.
			otherwise
				llReturn = .F.
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE Load
		* Set up the environment.
		
		set ansi       off
		set deleted    on
		set exact      off
		set exclusive  off
		set multilocks on
		set near       off
		set safety     off
		set talk       off
		set unique     off
		
	ENDPROC

	PROTECTED PROCEDURE loadtree		&& Loads the TreeView with the members for the object
		* Add records for public properties and methods to the My table.
		
		local loNode, ;
			lcMemberData, ;
			laLines[1], ;
			lnLines, ;
			lnI, ;
			lcLine, ;
			lnPos, ;
			lcMember, ;
			lcDescription, ;
			laComments[1], ;
			laMembers[1], ;
			lnMembers, ;
			lnLine, ;
			lcMetaData, ;
			lcSignature, ;
			lcNameSpace
		
		* Load the images for the ImageList control. 
		
		with This.oImageList
			.ImageHeight = 16
			.ImageWidth  = 16
			.ListImages.Add(1, 'Method', ;
				loadpicture(home() + 'ffc\graphics\method.bmp'))
			.ListImages.Add(2, 'Property', ;
				loadpicture(home() + 'ffc\graphics\propty.bmp'))
		endwith
		
		* Add "Methods" and "Properties" root nodes.
		
		with This.oTree
			.Object.ImageList = This.oImageList
			loNode = .Nodes.Add(, 1, '__RootMethods', 'Methods', 'Method')
			loNode.Expanded = .T.
			loNode.Sorted   = .T.
			loNode = .Nodes.Add(, 1, '__RootProperties', 'Properties', 'Property')
			loNode.Expanded = .T.
			loNode.Sorted   = .T.
		endwith
		with This.oObject
		
		* Get any MemberData for the object.
		
			if pemstatus(This.oObject, '_MemberData', 5)
				lcMemberData = ._MemberData
			else
				lcMemberData = ''
			endif pemstatus(This.oObject, '_MemberData', 5)
		
		* Open the FOXCODE table so we can look for global MemberData.
		
			try
				use (_foxcode) again shared in 0 alias FOXCODE
			catch
			endtry
		
		* Open the VCX and read descriptions.
		
			select 0
			try
				use (sys(1271, This.oObject)) again shared noupdate alias __VCX
			catch
			endtry
			if used('__VCX')
				locate for PLATFORM = 'WINDOWS' and OBJNAME = lower(.Class)
				lnLines = alines(laLines, RESERVED3)
				This.cDescription = iif(empty(This.cDescription), RESERVED7, ;
					This.cDescription)
				dimension laComments[lnLines, 2]
				use
				for lnI = 1 to lnLines
					lcLine = laLines[lnI]
					if left(lcLine, 1) = '*'
						lcLine = substr(lcLine, 2)
					endif left(lcLine, 1) = '*'
					lnPos              = at(' ', lcLine)
					lcMember           = left(lcLine, lnPos - 1)
					lcDescription      = substr(lcLine, lnPos + 1)
					laComments[lnI, 1] = lcMember
					laComments[lnI, 2] = lcDescription
				next lnI
			else
				laComments = ''
			endif used('__VCX')
		
		* Get a list of public user-defined members and go through each of them.
		
			lnMembers = amembers(laMembers, This.oObject, 1, 'GUC+')
			for lnI = 1 to lnMembers
				lcMember = laMembers[lnI, 1]
		
		* Get the description for the member.
		
				lnLine = ascan(laComments, lcMember, -1, -1, 1, 15)
				if lnLine > 0
					lcDescription = laComments[lnLine, 2]
				else
					lcDescription = ''
				endif lnLine > 0
		
		* If we have MemberData for this member, get the display name since AMEMBERS()
		* gives names in upper-case.
		
				lcMetaData = strextract(lcMemberData, 'name="' + lower(lcMember) + ;
					'"', '/>')
				do case
					case not empty(lcMetaData)
						lcMember = evl(strextract(lcMetaData, 'display="', '"'), ;
							lcMember)
					case used('FOXCODE')
						lnSelect = select()
						select FOXCODE
						locate for TYPE = 'E' and upper(ABBREV) = lcMember
						if found()
							lcMember = evl(strextract(TIP, 'display="', '"'), ;
								lcMember)
						endif found()
						select (lnSelect)
				endcase
				do case
		
		* If this is a method (we'll ignore certain methods that are public only
		* because we need to call them and Access and Assign methods), create the
		* signature for it by reading the code in the method. Then add it to the
		* TreeView.
		
					case laMembers[lnI, 2] = 'Method' and ;
						not inlist(right(upper(lcMember), 7), '_ACCESS', '_ASSIGN')
						lcSignature = lcMember + '('
						lcCode      = .ReadMethod(lcMember)
						alines(laCode, lcCode)
						lnLine = ascan(laCode, 'lpara', -1, -1, 1, 9)
						do while lnLine > 0
							lcLine = laCode[lnLine]
							if left(lower(lcLine), 5) = 'lpara'
								lcLine = substr(lcLine, at(' ', lcLine) + 1)
							endif left(lower(lcLine), 5) = 'lpara'
							lcLine      = alltrim(lcLine, 1, ' ', chr(9))
							lcSignature = lcSignature + lcLine
							if right(alltrim(lcLine, 1, ' ', chr(9)), 1) = ';'
								lcSignature = alltrim(left(lcSignature, ;
									len(lcSignature) - 1)) + ' '
								lnLine      = lnLine + 1
							else
								lnLine = 0
							endif right(alltrim(lcLine, 1, ' ', chr(9)), 1) = ';'
						enddo while lnLine > 0
						lcSignature = lcSignature + ')'
						lcNameSpace = This.cNameSpace + '.' + lcMember
						loNode      = This.oTree.Nodes.Add('__RootMethods', 4, ;
							lcMember, lcMember, 'Method')
						loNode.Checked = .T.
						if not seek(padr(upper(lcNameSpace), len(__MY.MEMBER)), ;
							'__MYCURSOR')
							insert into __MYCURSOR ;
									(MEMBER, ;
									TYPE) ;
								values ;
									(lcNameSpace, ;
									'M')
						endif not seek(padr(upper(lcNameSpace) ...
						if empty(__MYCURSOR.TIP)
							replace TIP with lcSignature in __MYCURSOR
						endif empty(__MYCURSOR.TIP)
						if empty(__MYCURSOR.DESCRIP)
							replace DESCRIP with lcDescription in __MYCURSOR
						endif empty(__MYCURSOR.DESCRIP)
		
		* If this is a property (we'll ignore certain properties that are public only
		* because we need to access them), add or update a record for it in the My
		* table.
		
					case laMembers[lnI, 2] = 'Property' and ;
						not inlist(upper(lcMember), 'CNAMESPACE', '_MEMBERDATA', ;
						'BUILDER', 'CCAPTION')
						lcNameSpace = This.cNameSpace + '.' + lcMember
						loNode      = This.oTree.Nodes.Add('__RootProperties', 4, ;
							lcMember, lcMember, 'Property')
						loNode.Checked = .T.
						if not seek(padr(upper(lcNameSpace), len(__MY.MEMBER)), ;
							'__MYCURSOR')
							insert into __MYCURSOR ;
									(MEMBER, ;
									TYPE) ;
								values ;
									(lcNameSpace, ;
									'P')
						endif not seek(padr(upper(lcNameSpace) ...
						if empty(__MYCURSOR.DESCRIP)
							replace DESCRIP with lcDescription in __MYCURSOR
						endif empty(__MYCURSOR.DESCRIP)
				endcase
			next lnI
		
		* Close the FOXCODE table.
		
			use in select('FOXCODE')
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE openmytable		&& Opens the My table
		local lcDir, ;
			lcTable, ;
			llReturn
		lcDir   = sys(16)
		lcDir   = addbs(justpath(substr(lcDir, at(' ', lcDir, 2) + 1)))
		lcTable = lcDir + 'my.dbf'
		if used('__MY')
			llReturn = .T.
		else
			try
				use (lcTable) again shared order MEMBER alias __MY in 0
				llReturn = .T.
			catch to loException
				llReturn = .F.
			endtry
		endif used('__MY')
		return llReturn
		
	ENDPROC

	PROCEDURE Refresh
		* Enable or disable the controls appropriately.
		
		with This
			do case
				case eof('__MYCURSOR')
					store .F. to .lblDescription.Enabled, .edtDescription.Enabled, ;
						.lblTip.Enabled, .edtTip.Enabled, ;
						.lblList.Enabled, .edtList.Enabled, ;
						.lblScript.Enabled, .edtScript.Enabled
				case __MYCURSOR.TYPE = 'P'
					store .T. to .lblDescription.Enabled, .edtDescription.Enabled, ;
						.lblScript.Enabled, .edtScript.Enabled
					store .F. to .lblTip.Enabled, .edtTip.Enabled, ;
						.lblList.Enabled, .edtList.Enabled
				otherwise
					store .T. to .lblDescription.Enabled, .edtDescription.Enabled, ;
						.lblTip.Enabled, .edtTip.Enabled, ;
						.lblList.Enabled, .edtList.Enabled, ;
						.lblScript.Enabled, .edtScript.Enabled
			endcase
		endwith
		
	ENDPROC

	PROCEDURE save		&& Saves the changes the user made
		* Save the changes.
		
		local loData, ;
			lcMember, ;
			loNode, ;
			llSave, ;
			llExists, ;
			lnSelect, ;
			lcAlias, ;
			lcType
		with This
		
		* Save the namespace if the class has a property for it.
		
			if pemstatus(.oObject, 'cNameSpace', 5) and ;
				.oObject.cNameSpace <> alltrim(.cNameSpace)
				.oObject.cNameSpace = alltrim(.cNameSpace)
			endif pemstatus(.oObject, 'cNameSpace', 5) ...
		
		* Save the member information.
		
			select __MYCURSOR
			set order to
			scan
				scatter memo name loData
				if TYPE <> 'C'
					lcMember = alltrim(substr(MEMBER, rat('.', MEMBER) + 1))
					if type('.oTree.Nodes(lcMember)') = 'O'
						loNode = .oTree.Nodes(lcMember)
						llSave = loNode.Checked
					else
						llSave = .F.
					endif type('.oTree.Nodes(lcMember)') = 'O'
				else
					llSave = .T.
					loData.Descrip = .cDescription
				endif TYPE <> 'C'
				llExists = seek(upper(loData.Member), '__MY')
				do case
					case not llExists and llSave
						insert into __MY from name loData
					case llExists and not llSave
						delete in __MY
					case llExists and llSave
						select __MY
						gather memo name loData
						select __MYCURSOR
				endcase
			endscan
		
		*** NEED TO REMOVE RECORDS IF RENAMED NAMESPACE
		
		* If this object isn't in the My namespace, add the necessary record to the
		* IntelliSense table.
		
			if upper(left(.cNameSpace, 3)) <> 'MY.'
				lnSelect = select()
				select 0
				try
					use (_foxcode) again shared
					lcAlias = alias()
				catch
				endtry
				if not empty(lcAlias)
		
		* Add the TYPE record if necessary.
		
					lcType = .cNameSpace
					locate for TYPE = 'T' and ;
						upper(ABBREV) = padr(upper(lcType), len(ABBREV)) and ;
						not deleted()
					if not found()
						insert into (lcAlias) ;
								(TYPE, ;
								ABBREV, ;
								CMD, ;
								DATA) ;
							values ;
								('T', ;
								lcType, ;
								'{MyScript}', ;
								lcType)
					endif not found()
		
		* Clean up and exit.
		
					use in (lcAlias)
				endif not empty(lcAlias)
				select (lnSelect)
			endif upper(left(.cNameSpace, 3)) <> 'MY.'
		endwith
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		Thisform.Release()
		
	ENDPROC

	PROCEDURE cmdOK.Click
		Thisform.Save()
		Thisform.Release()
		
	ENDPROC

	PROCEDURE oTree.KeyPress
		lparameters tnKeyASCII
		if tnKeyASCII = 27
			Thisform.Release()
		endif tnKeyASCII = 27
		
	ENDPROC

	PROCEDURE oTree.NodeClick
		lparameters toNode
		= seek(upper(alltrim(Thisform.cNameSpace) + '.' + toNode.Key), '__MYCURSOR')
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE tmrBuilder.Timer
		* Close the builder if the class was closed.
		
		if vartype(Thisform.oObject) <> 'O'
			Thisform.Release()
		endif vartype(Thisform.oObject) <> 'O'
		
	ENDPROC

	PROCEDURE txtNameSpace.GotFocus
		This.Tag = Thisform.cNameSpace
		
	ENDPROC

	PROCEDURE txtNameSpace.Valid
		local loObject, ;
			lcNameSpace, ;
			llValid, ;
			lnI, ;
			lcChar
		
		* If the Valid method fired because the user clicked on the Cancel button or
		* if we're closing the form, don't bother doing the rest of the validation.
		
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.Cancel') = 'L' ...
		
		* Don't allow illegal characters. This should be rewritten to use a regular
		* expression; for now, it's a brute force method.
		
		lcNameSpace = alltrim(This.Value)
		llValid     = .T.
		for lnI = 1 to len(lcNameSpace)
			lcChar = substr(lcNameSpace, lnI, 1)
			do case
		
		* The namespace can only consist of letters, digits, underscores, and periods.
		
				case not isalpha(lcChar) and not isdigit(lcChar) and not lcChar $ '_.'
					messagebox(ccERR_INVALID_CHAR_IN_NAMESPACE_LOC, ;
						MB_ICONEXCLAMATION, Thisform.Caption)
					llValid = .F.
					exit
		
		* The first character must be a letter.
		
				case not isalpha(lcChar) and lnI = 1
					messagebox(ccERR_FIRST_LETTER_LOC, MB_ICONEXCLAMATION, ;
						Thisform.Caption)
					llValid = .F.
					exit
		
		* The first namespace must be more than one letter long to prevent VFP from
		* thinking it's a workarea alias.
		
				case lcChar $ '_.' and lnI < 3
					messagebox(ccERR_NAMESPACE_TOO_SHORT_LOC, MB_ICONEXCLAMATION, ;
						Thisform.Caption)
					llValid = .F.
					exit
			endcase
		next lnI
		
		* Rename all records if the namespace was changed.
		
		if llValid and not lcNameSpace == This.Tag
			select __MYCURSOR
			replace all MEMBER with strtran(MEMBER, This.Tag, lcNameSpace)
		endif llValid ...
		return llValid
		
	ENDPROC

ENDDEFINE

DEFINE CLASS mycollection AS collection 		&& A case-insensitive Collection class
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	Height = 23
	Name = "mycollection"
	Width = 23
	
	PROCEDURE Add
		* Handle case-insensitive and duplicate keys.
		
		lparameters tuItem, ;
			tcKey, ;
			tuBefore, ;
			tuAfter
		local lcKey
		do case
			case pcount() = 1
				dodefault(tuItem)
			case vartype(tcKey) = 'C'
				lcKey = upper(tcKey)
				do case
					case This.GetKey(lcKey) > 0
					case pcount() = 2
						dodefault(tuItem, lcKey)
					case pcount() = 3
						dodefault(tuItem, lcKey, tuBefore)
					case pcount() = 4
						dodefault(tuItem, lcKey, tuBefore, tuAfter)
				endcase
			case pcount() = 3
				dodefault(tuItem, tcKey, tuBefore)
			case pcount() = 4
				dodefault(tuItem, tcKey, tuBefore, tuAfter)
		endcase
		nodefault
		
	ENDPROC

	PROCEDURE GetKey
		* Handle case-insensitive keys.
		
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex  = upper(tuIndex)
			luReturn = dodefault(lcIndex)
		else
			luReturn = dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE Item
		* Handle case-insensitive and non-existent keys.
		
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex = upper(tuIndex)
			if This.GetKey(lcIndex) = 0
				luReturn = .NULL.
			else
				luReturn = dodefault(lcIndex)
			endif This.GetKey(lcIndex) = 0
		else
			luReturn = dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		return luReturn
		
	ENDPROC

	PROCEDURE Remove
		* Handle case-insensitive keys.
		
		lparameters tuIndex
		local lcIndex, ;
			luReturn
		if vartype(tuIndex) = 'C'
			lcIndex = upper(tuIndex)
			dodefault(lcIndex)
		else
			dodefault(tuIndex)
		endif vartype(tuIndex) = 'C'
		nodefault
		
	ENDPROC

ENDDEFINE

DEFINE CLASS myfoxcode AS custom 		&& The IntelliSense handler for the My namespace
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: displayenumeratedvalues		&& Builds a list of enumerated values for IntelliSense to display
		*m: displaymembers		&& Builds a list of members for IntelliSense to display
		*m: getmembers		&& This code returns methods used for Intellisense
		*m: getmymember		&& Finds the record in the My table matching the member or method the user typed so far
		*m: handlelocal		&& Called when we were triggered in IntelliSense from the LOCAL AS statement
		*m: main		&& Main routine that gets called by IntelliSense engine.
		*m: openintellisense		&& Opens the IntelliSense table
		*m: openmytable		&& Opens the My table
		*p: ccurrdeleted		&& The current setting of SET DELETED
		*p: lerroroccurred		&& .T. if an error occurred
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	ccurrdeleted = 		&& The current setting of SET DELETED
	lerroroccurred = .F.		&& .T. if an error occurred
	Name = "myfoxcode"
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="main" type="method" display="Main"/>
		<memberdata name="getmembers" type="method" display="GetMembers"/>
		<memberdata name="getmymember" type="method" display="GetMyMember"/>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="handlelocal" type="method" display="HandleLOCAL"/>
		<memberdata name="displaymembers" type="method" display="DisplayMembers"/>
		<memberdata name="displayenumeratedvalues" type="method" display="DisplayEnumeratedValues"/>
		<memberdata name="openintellisense" type="method" display="OpenIntelliSense"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="ccurrdeleted" type="property" display="cCurrDeleted"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Destroy
		* Close the tables we opened and restore the setting of DELETED.
		
		use in select('__MY')
		use in select('__FOXCODE')
		if This.cCurrDeleted = 'OFF'
			set deleted off
		endif This.cCurrDeleted = 'OFF'
		
	ENDPROC

	PROTECTED PROCEDURE displayenumeratedvalues		&& Builds a list of enumerated values for IntelliSense to display
		lparameters toFoxCode, ;
			toData
		local laLines[1], ;
			lnLines, ;
			lnI, ;
			lcLine, ;
			lnPos, ;
			lcDescrip
		with toFoxCode
			lnLines = alines(laLines, toData.List)
			dimension .Items[lnLines, 2]
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
				lnPos  = at(',', lcLine)
				if lnPos > 0
					lcDescrip = alltrim(substr(lcLine, lnPos + 1))
					lcLine    = alltrim(left(lcLine, lnPos - 1))
				else
					lcDescrip = ''
				endif lnPos > 0
				.Items[lnI, 1] = lcLine
				.Items[lnI, 2] = lcDescrip
			next lnI
			.ValueType  = 'L'
			.ItemScript = 'funcmenu'
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE displaymembers		&& Builds a list of members for IntelliSense to display
		* Builds a list of members for IntelliSense to display.
		
		lparameters toFoxCode, ;
			toData
		local loMembers, ;
			lcPath, ;
			lnI, ;
			loMember
		with toFoxCode
		
		* Get a collection of members for the current class.
		
			loMembers = This.GetMembers(alltrim(toData.Member))
			if loMembers.Count > 0
		
		* Add each member to the Items array of the FoxCode object.
		
				dimension .Items[loMembers.Count, 2]
				lcPath = iif(file('propty.bmp'), '', home() + 'FFC\Graphics\')
				for lnI = 1 to loMembers.Count
					loMember       = loMembers.Item(lnI)
					.Items[lnI, 1] = loMember.Name
					.Items[lnI, 2] = loMember.Description
					if loMember.Type = 'P'
						.Icon = lcPath + 'propty.bmp'
					else
						.Icon = lcPath + 'method.bmp'
					endif loMember.Type = 'P'
				next loMember
		
		* Set the FoxCode object's ValueType property to "L", meaning display a listbox
		* containing the items defined in the Items array.
		
				.ValueType = 'L'
			endif loMembers.Count > 0
		endwith
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcMessage
		aerror(laError)
		This.lErrorOccurred = .T.
		lcMessage = ccERR_ERROR_MESSAGE_LOC
		lcMessage = strtran(lcMessage, '{1}', transform(tnError))
		lcMessage = strtran(lcMessage, '{2}', laError[2])
		lcMessage = strtran(lcMessage, '{3}', transform(tnLine))
		lcMessage = strtran(lcMessage, '{4}', tcMethod)
		messagebox(lcMessage, MB_ICONEXCLAMATION, ccCAP_MY_FOXCODE_LOC)
		
	ENDPROC

	PROCEDURE getmembers		&& This code returns methods used for Intellisense
		* Fill a collection with the members of the namespace found in the My registry
		* table.
		
		lparameters tcNameSpace
		local loCollection, ;
			lnSelect, ;
			lcNameSpace, ;
			lnLen, ;
			lcCursor, ;
			lcMember, ;
			loMember
		loCollection = createobject('Collection')
		lnSelect     = select()
		lcNameSpace  = upper(tcNameSpace) + '.'
		lnLen        = len(lcNameSpace) + 1
		lcCursor     = sys(2015)
		select * from __My where upper(MEMBER) like (lcNameSpace + '%') and not deleted() ;
			into cursor (lcCursor)
		scan
			lcMember = alltrim(substr(MEMBER, lnLen))
			if at('.', lcMember) = 0
				loMember = createobject('Empty')
				addproperty(loMember, 'Name',        lcMember)
				addproperty(loMember, 'Description', alltrim(DESCRIP))
				addproperty(loMember, 'Type',        TYPE)
				loCollection.Add(loMember)
			endif at('.', lcMember) = 0
		endscan
		use
		select (lnSelect)
		return loCollection
		
	ENDPROC

	PROTECTED PROCEDURE getmymember		&& Finds the record in the My table matching the member or method the user typed so far
		* Determine which member of the namespace the user typed and return a SCATTER
		* NAME object from the appropriate record in the FFI table.
		
		lparameters tcUserTyped, ;
			tcNameSpace
		local loReturn, ;
			lcUserTyped, ;
			llFound, ;
			lnPos, ;
			lcMember, ;
			lnSelect
		
		* Grab what the user typed. If it ends with an opening parenthesis, strip that
		* off.
		
		loReturn    = .NULL.
		lcUserTyped = alltrim(tcUserTyped)
		if right(lcUserTyped, 1) = '('
			lcUserTyped = substr(lcUserTyped, len(lcUserTyped) - 1)
		endif right(lcUserTyped, 1) = '('
		
		* Find the record for the class in the My table. If there's a period in the
		* typed text, try to find a record for the member.
		
		if seek(upper(padr(tcNameSpace, len(__My.CLASS))), '__My', 'MEMBER')
			llFound = .T.
			lnPos   = at('.', lcUserTyped)
			if lnPos > 0
				lcMember = alltrim(__My.MEMBER) + substr(lcUserTyped, lnPos)
				llFound  = seek(upper(padr(lcMember, len(__My.MEMBER))), '__My', ;
					'MEMBER')
			endif lnPos > 0
		
		* If we found the desired record, create a SCATTER NAME object for it.
		
			if llFound
				lnSelect = select()
				select __My
				scatter memo name loReturn
				select (lnSelect)
			endif llFound
		endif seek(upper(padr(tcNameSpace ...
		return loReturn
		
	ENDPROC

	PROTECTED PROCEDURE handlelocal		&& Called when we were triggered in IntelliSense from the LOCAL AS statement
		* Handle being triggered from the LOCAL AS statement.
		
		lparameters toFoxCode, ;
			tcNameSpace, ;
			tcClass, ;
			tcLibrary
		local lcCode, ;
			lcCase, ;
			lcVariable, ;
			lcReturn
		with toFoxCode
			lcCode = 'NEWOBJECT'
			lcCase = ''
		
		* Open the IntelliSense table and find the record for the NEWOBJECT function.
		* If we did, get the case we're supposed to use. If it specifies the default
		* IntelliSense case, get that from the V record.
		
			if This.OpenIntelliSense() and seek('FNEWO', '__FOXCODE', 1)
				lcCase = __FOXCODE.CASE
				lcCode = alltrim(__FOXCODE.EXPANDED)
				if empty(lcCase) and seek('V', '__FOXCODE', 1)
					lcCase = __FOXCODE.CASE
				endif empty(lcCase) ...
			endif This.OpenIntelliSense() ...
		
		* Handle the case as specified.
		
			do case
				case lcCase = 'U'
					lcCode = upper(lcCode)
				case lcCase = 'L'
					lcCode = lower(lcCode)
				case lcCase = 'P'
					lcCode = proper(lcCode)
			endcase
		
		* Get the variable name the user typed in the LOCAL VariableName AS statement,
		* then construct the code we want inserted and set the ValueType property of
		* the FoxCode object to "V" so it inserts this string.
		
			lcVariable = substr(.FullLine, rat(' ', .FullLine) + 1)
		*** Note: we'll use KEYBOARD rather than including the code to add in lcReturn
		*** so the code is indented properly if necessary
		***	lcReturn   = tcNameSpace + chr(13) + lcVariable + ' = ' + lcCode + "('" + ;
				tcClass + "', '" + tcLibrary + "')" + chr(13)
			lcReturn   = tcNameSpace
			if not This.lErrorOccurred
				keyboard chr(13) + lcVariable + ' = ' + lcCode + "('" + ;
					tcClass + "', '" + tcLibrary + "')" + chr(13) plain
			endif not This.lErrorOccurred
			.ValueType = 'V'
		endwith
		return lcReturn
		
	ENDPROC

	PROCEDURE Init
		* Turn debugging on.
		
		sys(2030, 1)
		
		* Open the My table.
		
		local llReturn
		llReturn = This.OpenMyTable()
		if not llReturn
			messagebox(ccERR_COULD_NOT_OPEN_MY_LOC, MB_ICONEXCLAMATION, ;
				ccCAP_MY_FOXCODE_LOC)
		endif not llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE main		&& Main routine that gets called by IntelliSense engine.
		* This is main routine that gets called from the IntelliSense script for My.
		
		lparameters toFoxCode
		local lcNameSpace, ;
			loData, ;
			lcReturn, ;
			lcTrigger
		with toFoxCode
			.ValueType = 'V'
		
		* Get the namespace and an object from the My table for that namespace.
		
			lcNameSpace = .Data
			loData      = This.GetMyMember(.UserTyped, lcNameSpace)
			lcReturn    = ''
			do case
		
		* We couldn't figure out which member was specified.
		
				case vartype(loData) <> 'O'
		
		* If we're on the LOCAL statement, handle that by returning text we want
		* inserted.
		
				case atc(lcNameSpace, .MenuItem) > 0
					lcReturn = This.HandleLOCAL(toFoxCode, lcNameSpace, ;
						trim(loData.Class), trim(loData.Library))
		
		* Other IntelliSense. Start by getting the character that triggered
		* IntelliSense.
		
				otherwise
					lcTrigger = right(.FullLine, 1)
					do case
		
		* If we were triggered by a ".", display a list of members.
		
						case lcTrigger = '.'
							This.DisplayMembers(toFoxCode, loData)
		
		* If we were triggered by a "(" (to start a method parameter list) and the
		* method accepts enumerated values specified in the LIST memo, display them.
		
						case lcTrigger = '(' and not empty(loData.List)
							This.DisplayEnumeratedValues(toFoxCode, loData)
		
		* If we were triggered by a "(" (to start a method parameter list), an "="
		* (for a property), or "," (to enter a new parameter) and we have a script,
		* execute it.
		
						case inlist(lcTrigger, '=', '(', ',') and ;
							not empty(loData.Script)
							lcReturn = execscript(loData.Script, toFoxCode, loData)
		
		* If we were triggered by a "(" (to start a method parameter list) or "," (to
		* enter a new parameter), display the parameters for the method.
		
						case inlist(lcTrigger, '(', ',') and not empty(loData.Tip)
							.ValueTip  = loData.Tip
							.ValueType = 'T'
					endcase
			endcase
		endwith
		return lcReturn
		
	ENDPROC

	PROTECTED PROCEDURE openintellisense		&& Opens the IntelliSense table
		local lcDir, ;
			lcTable, ;
			llReturn
		if used('__FOXCODE')
			llReturn = .T.
		else
			try
				use (_foxcode) again shared alias __FOXCODE in 0
				llReturn = .T.
			catch to loException
				llReturn = .F.
			endtry
		endif used('__FOXCODE')
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE openmytable		&& Opens the My table
		local lcDir, ;
			lcTable, ;
			llReturn
		lcDir   = sys(16)
		lcDir   = addbs(justpath(substr(lcDir, at(' ', lcDir, 2) + 1)))
		lcTable = lcDir + 'my.dbf'
		if used('__MY')
			llReturn = .T.
		else
			try
				use (lcTable) again shared alias __MY in 0
				llReturn = .T.
			catch to loException
				llReturn = .F.
			endtry
		endif used('__MY')
		
		* If we successfully opened the table, save the current setting of DELETED and
		* turn it on.
		
		if llReturn
			This.cCurrDeleted = set('Deleted')
			set deleted on
		endif llReturn
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS network AS mybase OF "my.vcx" 		&& Provides properties and methods dealing with networks
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: downloadfile		&& Downloads the specified file to the specified location
		*m: mapnetworkdrive		&& Maps to a network drive
		*m: removenetworkdrive		&& Removes a mapping for a network drive
		*p: owsh		&& A reference to the Windows Script Host object
	*</DefinedPropArrayMethod>

	PROTECTED owsh
	cnamespace = My.Computer.Network
	Name = "network"
	owsh = .NULL.		&& A reference to the Windows Script Host object
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="mapnetworkdrive" type="method" display="MapNetworkDrive"/>
		<memberdata name="downloadfile" type="method" display="DownloadFile"/>
		<memberdata name="owsh" type="property" display="oWSH"/>
		<memberdata name="removenetworkdrive" type="method" display="RemoveNetworkDrive"/>
		</VFPData>
	
	PROCEDURE Destroy
		* Nuke all memebers.
		
		This.oWSH = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE downloadfile		&& Downloads the specified file to the specified location
		* Download the specified file over the Internet.
		
		lparameters URL as String, ;
			Destination as String
		local lnResult
		if vartype(URL) <> 'C' or empty(URL) or ;
			vartype(Destination) <> 'C' or empty(Destination)
			error cnERR_ARGUMENT_INVALID
			lnResult = -1
		else
			declare long URLDownloadToFile in URLMON.DLL long, string, string, long, ;
				long
			lnResult = URLDownloadToFile(0, URL, Destination, 0, 0)
		endif vartype(URL) <> 'C' ...
		return lnResult
		
	ENDPROC

	PROCEDURE Init
		* Create an instance of the Windows Script Host.
		
		This.oWSH = createobject('WScript.Network')
		
	ENDPROC

	PROCEDURE mapnetworkdrive		&& Maps to a network drive
		* Map the specified UNC path to the specified drive.
		
		lparameters DriveLetter as String, ;
			UNCPath as String, ;
			ReconnectAtLogon as Logical, ;
			UserName as String, ;
			Password as String
		local lnResult
		do case
			case vartype(DriveLetter) <> 'C' or len(DriveLetter) <> 2 or ;
				not isalpha(left(DriveLetter, 1)) or right(DriveLetter, 1) <> ':' or ;
				vartype(UNCPath) <> 'C' or empty(UNCPath) or ;
				(pcount() >= 3 and vartype(ReconnectAtLogon) <> 'L') or ;
				(pcount() >= 4 and (vartype(UserName) <> 'C' or empty(UserName))) or ;
				(pcount() = 5 and (vartype(Password) <> 'C' or empty(Password)))
				error cnERR_ARGUMENT_INVALID
			case pcount() > 3
				lnResult = This.oWSH.MapNetworkDrive(DriveLetter, UNCPath, ;
					ReconnectAtLogon, UserName, Password)
			otherwise
				lnResult = This.oWSH.MapNetworkDrive(DriveLetter, UNCPath, ;
					ReconnectAtLogon)
		endcase
		return lnResult
		
	ENDPROC

	PROCEDURE removenetworkdrive		&& Removes a mapping for a network drive
		* Map the specified UNC path to the specified drive.
		
		lparameters DriveLetter as String, ;
			Force as Logical, ;
			UpdateUserProfile as Logical
		local lnResult
		if vartype(DriveLetter) <> 'C' or vartype(Force) <> 'L' or ;
			vartype(UpdateUserProfile) <> 'L'
			error cnERR_ARGUMENT_INVALID
		else
			lnResult = This.oWSH.RemoveNetworkDrive(DriveLetter, Force, ;
				UpdateUserProfile)
		endif vartype(DriveLetter) <> 'C' ...
		return lnResult
		
	ENDPROC

ENDDEFINE

DEFINE CLASS printer AS mybase OF "my.vcx" 		&& Provides information about printers
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: availableprinters_access
		*m: availableprinters_assign
		*m: defaultvfpprinter_access
		*m: defaultvfpprinter_assign
		*m: defaultwindowsprinter_access
		*m: defaultwindowsprinter_assign
		*m: pagesetup		&& Displays the Page Setup dialog
		*p: availableprinters		&& A collection of objects containing information about the available printers
		*p: defaultvfpprinter		&& The name of the default VFP printer
		*p: defaultwindowsprinter		&& The name of the default Windows printer
	*</DefinedPropArrayMethod>

	availableprinters = .NULL.		&& A collection of objects containing information about the available printers
	cnamespace = My.Computer.Printer
	defaultvfpprinter = 		&& The name of the default VFP printer
	defaultwindowsprinter = 		&& The name of the default Windows printer
	Name = "printer"
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="availableprinters" type="property" display="AvailablePrinters"/>
		<memberdata name="availableprinters_access" type="property" display="AvailablePrinters_Access"/>
		<memberdata name="availableprinters_assign" type="property" display="AvailablePrinters_Assign"/>
		<memberdata name="defaultvfpprinter" type="property" display="DefaultVFPPrinter"/>
		<memberdata name="defaultvfpprinter_access" type="property" display="DefaultVFPPrinter_Access"/>
		<memberdata name="defaultvfpprinter_assign" type="property" display="DefaultVFPPrinter_Assign"/>
		<memberdata name="defaultwindowsprinter" type="property" display="DefaultWindowsPrinter"/>
		<memberdata name="defaultwindowsprinter_access" type="property" display="DefaultWindowsPrinter_Access"/>
		<memberdata name="defaultwindowsprinter_assign" type="property" display="DefaultWindowsPrinter_Assign"/>
		<memberdata name="pagesetup" type="method" display="PageSetup"/>
		</VFPData>
	
	PROCEDURE availableprinters_access
		local laPrinters[1], ;
			lnI, ;
			loPrinter
		
		* Clear the collection if we already have one or instantiate it if not.
		
		if vartype(This.AvailablePrinters) = 'O'
			This.AvailablePrinters.Remove(-1)
		else
			This.AvailablePrinters = newobject('MyCollection', 'My.vcx')
		endif vartype(This.AvailablePrinters) = 'O'
		
		* Fill the collection with objects containing information about the available
		* printers.
		
		for lnI = 1 to aprinters(laPrinters, 1)
			loPrinter = createobject('Empty')
			addproperty(loPrinter, 'PrinterName', laPrinters[lnI, 1])
			addproperty(loPrinter, 'Port',        laPrinters[lnI, 2])
			addproperty(loPrinter, 'Driver',      laPrinters[lnI, 3])
			addproperty(loPrinter, 'Comment',     laPrinters[lnI, 4])
			addproperty(loPrinter, 'Location',    laPrinters[lnI, 5])
			This.AvailablePrinters.Add(loPrinter, laPrinters[lnI, 1])
		next lnI
		return This.AvailablePrinters
		
	ENDPROC

	PROCEDURE availableprinters_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tuValue
		if This.CalledFromThisClass()
			This.AvailablePrinters = tuValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'AvailablePrinters'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE defaultvfpprinter_access
		* Because SET('PRINTER', 3) returns the default VFP printer in upper-case,
		* we'll check the AvailablePrinters collection so we can return the name in the
		* correct case.
		
		local lcName, ;
			loPrinter
		lcName    = set('PRINTER', 3)
		loPrinter = This.AvailablePrinters.Item(lcName)
		if vartype(loPrinter) = 'O'
			lcName = loPrinter.PrinterName
		endif vartype(loPrinter) = 'O'
		return lcName
		
	ENDPROC

	PROCEDURE defaultvfpprinter_assign
		* Set the default printer to the specified one if it exists (the string
		* "default" can be used to set the printer to the default Windows printer).
		
		lparameters tcPrinterName
		do case
			case not vartype(tcPrinterName) = 'C' and not empty(tcPrinterName)
				error cnERR_ARGUMENT_INVALID
			case upper(tcPrinterName) = 'DEFAULT'
				set printer to default
			otherwise
				loPrinter = This.AvailablePrinters.Item(tcPrinterName)
				if vartype(loPrinter) = 'O'
					set printer to name (tcPrinterName)
				endif vartype(loPrinter) = 'O'
		endcase
		
	ENDPROC

	PROCEDURE defaultwindowsprinter_access
		* Because SET('PRINTER', 2) returns the default Windows printer in upper-case,
		* we'll check the AvailablePrinters collection so we can return the name in the
		* correct case.
		
		local lcName, ;
			loPrinter
		lcName = set('PRINTER', 2)
		loPrinter = This.AvailablePrinters.Item(lcName)
		if vartype(loPrinter) = 'O'
			lcName = loPrinter.PrinterName
		endif vartype(loPrinter) = 'O'
		return lcName
		
	ENDPROC

	PROCEDURE defaultwindowsprinter_assign
		* Throw a "property is read-only" error.
		
		lparameters tuValue
		error cnERR_PROPERTY_READ_ONLY, 'DefaultWindowsPrinter'
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.AvailablePrinters = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE pagesetup		&& Displays the Page Setup dialog
		local llReturn
		llReturn = sys(1037, 0) = '1'
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS registry AS mybase OF "my.vcx" 		&& Provides access to the Windows Registry
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myregistry.h"
	*<DefinedPropArrayMethod>
		*m: closekey		&& Closes the current registry key
		*m: deletekey		&& Deletes the specified key
		*m: deletekeyvalue		&& Deletes the specified value from the specified key
		*m: enumeratekeys		&& Returns a collection of keys in the specified key
		*m: enumeratekeyvalues		&& Returns a collection of keys and values in the specified key
		*m: getkey		&& Gets the hive and key from the specified key
		*m: getvalue		&& Gets the specified value from the specified key
		*m: openkey		&& Opens the specified key
		*m: setvalue		&& Sets the specified value in the specified registry key
		*p: ccurrentkey		&& The key to use for the current access
		*p: ncurrentkey		&& The current open key handle
		*p: ncurrentmainkey		&& The current hive being accessed
		*p: nmainkey		&& The default hive being accessed
	*</DefinedPropArrayMethod>

	PROTECTED ccurrentkey,ncurrentkey,ncurrentmainkey,nmainkey
	ccurrentkey = 		&& The key to use for the current access
	cnamespace = My.Computer.Registry
	Name = "registry"
	ncurrentkey = 0		&& The current open key handle
	ncurrentmainkey = 0		&& The current hive being accessed
	nmainkey = 0		&& The default hive being accessed
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="closekey" type="method" display="CloseKey"/>
		<memberdata name="deletekey" type="method" display="DeleteKey"/>
		<memberdata name="deletekeyvalue" type="method" display="DeleteKeyValue"/>
		<memberdata name="getkey" type="method" display="GetKey"/>
		<memberdata name="getvalue" type="method" display="GetValue"/>
		<memberdata name="openkey" type="method" display="OpenKey"/>
		<memberdata name="setvalue" type="method" display="SetValue"/>
		<memberdata name="ccurrentkey" type="property" display="cCurrentKey"/>
		<memberdata name="ncurrentkey" type="property" display="nCurrentKey"/>
		<memberdata name="ncurrentmainkey" type="property" display="nCurrentMainKey"/>
		<memberdata name="nmainkey" type="property" display="nMainKey"/>
		<memberdata name="enumeratekeys" type="method" display="EnumerateKeys"/>
		<memberdata name="enumeratekeyvalues" type="method" display="EnumerateKeyValues"/>
		</VFPData>
	
	PROTECTED PROCEDURE closekey		&& Closes the current registry key
		* Close the current key and blank the current key value.
		
		with This
			RegCloseKey(.nCurrentKey)
			.nCurrentKey = 0 
		endwith
		
	ENDPROC

	PROCEDURE deletekey		&& Deletes the specified key
		* Delete the specified key and all subkeys and values under it.
		
		lparameters Key as String
		local lcCurrentKey, ;
			loKeys, ;
			llReturn, ;
			lcKey, ;
			lnResult
		with This
		
		* Get the key and hive to use, then get a collection of subkeys and delete
		* each one by calling ourselves recursively. Then delete the key and return .T.
		* if it succeeded.
		
			if .GetKey(Key)
				lcCurrentKey = .cCurrentKey
				loKeys       = .EnumerateKeys(Key)
				llReturn     = .T.
				for each lcKey in loKeys
					lcKey    = addbs(Key) + lcKey
					llReturn = .DeleteKey(lcKey)
					if not llReturn
						exit
					endif not llReturn
				next lcKey
				.cCurrentKey = lcCurrentKey
				if llReturn
					lnResult = RegDeleteKey(.nCurrentMainKey, .cCurrentKey)
					llReturn = lnResult = cnSUCCESS
				endif llReturn
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
			endif .GetKey(Key)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE deletekeyvalue		&& Deletes the specified value from the specified key
		* Delete the specified value in the specified key.
		
		lparameters Key as String, ;
			ValueName as String
		local lnResult, ;
			llReturn
		with This
		
		* Give an error if the value name wasn't specified.
		
			do case
				case vartype(ValueName) <> 'C' or empty(ValueName)
					error cnERR_ARGUMENT_INVALID
		
		* Get the key and hive to use. If we succeeded, try to open the registry key.
		* If we could, delete the specified value name.
		
				case .GetKey(Key)
					if .OpenKey(.cCurrentKey, .nCurrentMainKey)
						lnResult = RegDeleteValue(.nCurrentKey, ValueName)
						llReturn = lnResult = cnSUCCESS
						.CloseKey()
					endif .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Give an error if the key wasn't specified properly.
		
				otherwise
					error cnERR_ARGUMENT_INVALID
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE enumeratekeys		&& Returns a collection of keys in the specified key
		lparameters Key as String
		local loKeys as Collection, ;
			lnNames, ;
			lnResult, ;
			lcKey, ;
			lnSize, ;
			lcBuffer1, ;
			lnSize1, ;
			lcBuffer2
		with This
		
		* Instantiate a collection to return.
		
			loKeys = createobject('Collection')
		
		* Get the key and hive to use.
		
			if .GetKey(Key)
		
		* Try to open the registry key. If we couldn't, return an empty collection.
		
				if .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Initialize the number of names and the result code.
		
					lnNames  = 0
					lnResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
					do while lnResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
						lcKey     = space(cnBUFFER_SIZE)
						lnSize    = cnBUFFER_SIZE
						lcBuffer1 = space(cnBUFFER_SIZE)
						lnSize1   = cnBUFFER_SIZE
						lcBuffer2 = space(cnBUFFER_SIZE)
		
		* Get the next key name from the Registry.
		
						lnResult = RegEnumKeyEx(.nCurrentKey, lnNames, @lcKey, ;
							@lnSize, cnRESERVED, @lcBuffer1, @lnSize1, @lcBuffer2)
		
		* If we got a name, add it to the collection.
		
						if lnResult = cnSUCCESS
							lcKey   = alltrim(lcKey)
							lcKey   = left(lcKey, len(lcKey) - 1)
							lnNames = lnNames + 1
							loKeys.Add(lcKey)
						endif lnResult = cnSUCCESS
					enddo while lnResult = cnSUCCESS
		
		* Close the registry key.
		
					.CloseKey()
				endif .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
			endif .GetKey(tcKey)
		endwith
		return loKeys
		
	ENDPROC

	PROCEDURE enumeratekeyvalues		&& Returns a collection of keys and values in the specified key
		lparameters Key as String
		local loValues as Collection, ;
			lnValues, ;
			lnResult, ;
			lcKey, ;
			lnKeySize, ;
			lcValue, ;
			lnValSize, ;
			lnType, ;
			luValue
		with This
		
		* Instantiate a collection to return.
		
			loValues = createobject('Collection')
		
		* Get the key and hive to use.
		
			if .GetKey(Key)
		
		* Try to open the registry key. If we couldn't, return an empty collection.
		
				if .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Initialize the number of names and the result code.
		
					lnValues = 0
					lnResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
					do while lnResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
						lcKey     = space(cnBUFFER_SIZE)
						lnKeySize = cnBUFFER_SIZE
						lcValue   = space(cnBUFFER_SIZE)
						lnValSize = cnBUFFER_SIZE
						lnType    = 0
		
		* Get the next key name from the Registry.
		
						lnResult = RegEnumValue(.nCurrentKey, lnValues, @lcKey, ;
							@lnKeySize, cnRESERVED, @lnType, @lcValue, @lnValSize)
		
		* If we got a name, add it to the collection.
		
						if lnResult = cnSUCCESS
							lcKey    = left(lcKey, lnKeySize)
							lnValues = lnValues + 1
							do case
								case lnType = cnREG_SZ
									luValue = left(lcValue, lnValSize - 1)
								case lpdwType = cnREG_DWORD
									luValue = ctobin(left(lcValue, 4), 'RS')
								otherwise
									luValue = ''
							endcase
							loValues.Add(luValue, lcKey)
						endif lnResult = cnSUCCESS
					enddo while lnResult = cnSUCCESS
		
		* Close the registry key.
		
					.CloseKey()
				endif .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
			endif .GetKey(tcKey)
		endwith
		return loValues
		
	ENDPROC

	PROTECTED PROCEDURE getkey		&& Gets the hive and key from the specified key
		lparameters tcKey
		local llReturn, ;
			lnPos, ;
			lcMainKey
		with This
		
		* Ensure the key was specified.
		
			llReturn = .T.
			do case
				case vartype(tcKey) <> 'C' or empty(tcKey)
					llReturn = .F.
		
		* If the hive was included in the key, get it. Otherwise, use the default
		* value.
		
				case upper(left(tcKey, 5)) = 'HKEY_'
					lnPos     = at('\', tcKey)
					lcMainKey = upper(left(tcKey, lnPos - 1))
					do case
						case lcMainKey = 'HKEY_CLASSES_ROOT'
							.nCurrentMainKey = cnHKEY_CLASSES_ROOT
						case lcMainKey = 'HKEY_CURRENT_USER'
							.nCurrentMainKey = cnHKEY_CURRENT_USER
						case lcMainKey = 'HKEY_LOCAL_MACHINE'
							.nCurrentMainKey = cnHKEY_LOCAL_MACHINE
						case lcMainKey = 'HKEY_USERS'
							.nCurrentMainKey = cnHKEY_USERS
						otherwise
							llReturn = .F.
					endcase
					.cCurrentKey = substr(tcKey, lnPos + 1)
				otherwise
					.nCurrentMainKey = .nMainKey
					.cCurrentKey     = tcKey
			endcase
		
		* Strip any trailing backslash off the key (Windows 95/98 won't accept a
		* trailing backslash).
		
			if llReturn
				.cCurrentKey = iif(right(.cCurrentKey, 1) = '\', ;
					left(.cCurrentKey, len(.cCurrentKey) - 1), .cCurrentKey)
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE getvalue		&& Gets the specified value from the specified key
		lparameters Key as String, ;
			ValueName as String, ;
			DefaultValue as Variant
		local luValue, ;
			lcValueName, ;
			lcBuffer, ;
			lnSize, ;
			lnType, ;
			lnResult
		with This
		
		* Get the key and hive to use.
		
			if .GetKey(Key)
		
		* If the default to use wasn't passed, initialize it to an empty string.
		
				luValue = iif(vartype(DefaultValue) = 'C', DefaultValue, '')
		
		* If the value name wasn't specified, initialize it to an empty string.
		
				lcValueName = iif(pcount() = 1, '', ValueName)
		
		* Try to open the registry key. If we couldn't, return the default value.
		
				if .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Create a buffer to hold the key value.
		
					lcBuffer = space(cnBUFFER_SIZE)
					lnSize   = cnBUFFER_SIZE
					lnType   = 0
		
		* Set the key value. Make sure we have a data string data type.
		
					lnResult = RegQueryValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
						@lnType, @lcBuffer, @lnSize)
					if lnResult = cnSUCCESS and lnType = cnREG_SZ
						luValue = left(lcBuffer, lnSize - 1)
					endif lnResult ...
		
		* Close the registry key and return the value.
		
					.CloseKey()
				endif .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
				luValue = .NULL.
			endif .GetKey(tcKey)
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE Init
		* Declare the API functions we'll need.
		
		declare integer RegOpenKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegCreateKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegDeleteKey in Win32API ;
			integer nKey, string @cSubKey
		declare integer RegCloseKey in Win32API ;
			integer nKey
		declare integer RegSetValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer nType, string cBuffer, integer nBufferSize
		declare integer RegQueryValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer @nType, string @cBuffer, integer @nBufferSize
		declare integer RegDeleteValue in Win32API ;
			integer nKey, string cSubKey
		declare integer RegEnumKeyEx in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize,;
			integer nReserved, string @cBuffer, integer @nBufferSize, string @cBuffer
		declare integer RegEnumValue IN Win32API ;
			integer nKey, integer nValue, string @cSubKey, ;
			integer @nKeySize, integer nReserved, integer @nType, ;
			string @cValue, integer @nValSize
		
		* Initialize the main key to the default HKEY_CURRENT_USER.
		
		This.nMainKey = cnHKEY_CURRENT_USER
		
		* Carry on with the base behavior.
		
		dodefault()
		
	ENDPROC

	PROTECTED PROCEDURE openkey		&& Opens the specified key
		lparameters tcSubKey, ;
			tnMainKey, ;
			tlCreate
		local lnHandle, ;
			lcSubKey, ;
			lnResult, ;
			llReturn
		
		* Try to create or open the registry key. If it succeeded, store the key handle
		* in the nCurrentKey property; if not, zero nCurrentKey.
		
		with This
			lnHandle = 0
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
			lcSubKey = iif(right(tcSubKey, 1) = '\', ;
				left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
			if tlCreate
				lnResult = RegCreateKey(tnMainKey, lcSubKey, @lnHandle)
			else
				lnResult = RegOpenKey(tnMainKey, lcSubKey, @lnHandle)
			endif tlCreate
			llReturn     = lnResult = cnSUCCESS
			.nCurrentKey = iif(llReturn, lnHandle, 0)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE setvalue		&& Sets the specified value in the specified registry key
		lparameters Key as String, ;
			ValueName as String, ;
			Value as Variant
		local lcType, ;
			lcValue, ;
			lnSize, ;
			lcValueName, ;
			lnResult, ;
			llReturn
		with This
		
		* Get the key and hive to use.
		
			if .GetKey(Key)
		
		* Convert the value to a string if necessary. Terminate the string with a null
		* and calculate the size.
		
				lcType = vartype(Value)
				do case
					case lcType = 'C'
						lcValue = Value
					case lcType $ 'NIFYB'
						lcValue = transform(Value)
					case lcType = 'D'
						lcValue = dtoc(Value)
					case lcType = 'T'
						lcValue = ttoc(Value)
					case lcType = 'L'
						lcValue = iif(Value, 'Y', 'N')
				endcase
				lcValue = lcValue + ccNULL
				lnSize  = len(lcValue)
		
		* If the value name wasn't specified, initialize it to an empty string.
		
				lcValueName = iif(vartype(ValueName) = 'C', ValueName, '')
		
		* Try to open or create the registry key. If we couldn't, return .F.
		
				if .OpenKey(.cCurrentKey, .nCurrentMainKey, .T.)
		
		* Set the key value.
		
					lnResult = RegSetValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
						cnREG_SZ, lcValue, lnSize)
					llReturn = lnResult = cnSUCCESS
		
		* Close the registry key and return the success flag.
		
					.CloseKey()
				endif .OpenKey(.cCurrentKey, .nCurrentMainKey, .T.)
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
			endif .GetKey(Key)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE

DEFINE CLASS settings AS mybase OF "my.vcx" 		&& Provides application settings
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: add		&& Adds a new setting
		*m: exists		&& Returns .T. if the specified setting exists
		*m: load		&& Loads the settings from the specified file
		*m: save		&& Saves the settings to the specified file
		*p: osettings		&& A collection of settings
	*</DefinedPropArrayMethod>

	PROTECTED osettings
	cnamespace = My.Settings
	Name = "settings"
	osettings = .NULL.		&& A collection of settings
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="load" type="method" display="Load"/>
		<memberdata name="save" type="method" display="Save"/>
		<memberdata name="osettings" type="property" display="oSettings"/>
		<memberdata name="add" type="method" display="Add"/>
		<memberdata name="exists" type="method" display="Exists"/>
		</VFPData>
	
	PROCEDURE add		&& Adds a new setting
		* Add a new setting to our collection and as a property.
		
		lparameters SettingName as String, Value as Variant
		local loException as Exception
		if vartype(SettingName) <> 'C' or empty(SettingName) or ;
			vartype(Value) = 'O'
			error cnERR_ARGUMENT_INVALID
		else
			try
				This.AddProperty(SettingName, Value)
				This.oSettings.Add(SettingName, SettingName)
			catch to loException when loException.ErrorNo = cnERR_KEY_EXISTS
				store Value to ('This.' + SettingName)
			catch to loException
				throw
			endtry
		endif vartype(SettingName) <> 'C' ...
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oSettings = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE exists		&& Returns .T. if the specified setting exists
		* Return .T. if the specified setting exists.
		
		lparameters SettingName as String
		local llReturn
		if vartype(SettingName) <> 'C' or empty(SettingName)
			error cnERR_ARGUMENT_INVALID
			llReturn = .F.
		else
			llReturn = This.oSettings.GetKey(SettingName) > 0
		endif vartype(SettingName) <> 'C' ...
		return llReturn
		
	ENDPROC

	PROCEDURE Init
		* Create a collection of setting names.
		
		This.oSettings = newobject('MyCollection', 'My.vcx')
		dodefault()
		
	ENDPROC

	PROCEDURE load		&& Loads the settings from the specified file
		* Load the specified settings file.
		
		lparameters SettingsFile as String
		local loDOM, ;
			loNodes, ;
			loNode, ;
			llCast, ;
			lcName, ;
			lcType, ;
			loValue, ;
			lcValue, ;
			lnPos, ;
			lnDigits, ;
			lnDec, ;
			llReturn
		do case
		
		* We weren't passed a valid file name, so give an error and exit.
		
			case vartype(SettingsFile) <> 'C' or empty(SettingsFile)
				error cnERR_ARGUMENT_INVALID
			case not file(SettingsFile)
				error cnERR_FILE_NOT_FOUND, SettingsFile
			otherwise
		
		* Create an MSXML DOMDocument object and load the XML.
		
				try
					loDOM = createobject('MSXML2.DOMDocument.3.0')
					loDOM.async = .F.
					loDOM.preserveWhiteSpace = .T.
					loDOM.load(SettingsFile)
				catch to loException
					loDOM = .NULL.
				endtry
				do case
		
		* We couldn't create the object.
		
					case vartype(loDOM) <> 'O'
						error 'Could not create MSXML DOMDocument object'
		
		* The XML was loaded, so parse it into individual settings.
		
					case loDOM.parseError.errorCode = 0
						loNodes = loDOM.selectNodes('/SettingsFile/Settings/Setting')
						for each loNode in loNodes
							llCast  = .T.
							lcName  = loNode.getAttribute('Name')
							lcType  = loNode.getAttribute('Type')
							loValue = loNode.selectSingleNode('Value')
							lcValue = loValue.text
							do case
								case lcType = ccSTRING
									llCast  = .F.
									luValue = lcValue
								case lcType = ccINTEGER
									lcType = 'I'
								case lcType = ccBOOLEAN
									lcType = 'L'
								case lcType = ccDOUBLE
									lnPos    = at('.', lcValue)
									lnDigits = len(lcValue)
									lnDec    = iif(lnPos > 0, len(lcValue) - lnPos, 0)
									lcType   = 'N(' + transform(lnDigits) + ',' + ;
										transform(lnDec) + ')'
								case lcType = ccCURRENCY
									lcType = 'Y'
								case lcType = ccDATETIME
									llCast  = .F.
									luValue = ctot(lcValue)
							endcase
							try
								if llCast
									luValue = cast(lcValue as &lcType)
								endif llCast
								This.Add(lcName, luValue)
							catch to loException
								throw
							endtry
						next loNode
						llReturn = .T.
				endcase
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE save		&& Saves the settings to the specified file
		lparameters SettingsFile as String
		local loDOM, ;
			loInstruction, ;
			loRoot, ;
			loBlank, ;
			loProfiles, ;
			loSettings, ;
			lcName, ;
			luValue, ;
			lcType, ;
			loSetting, ;
			lcValue
		
		* We weren't passed a valid file name, so give an error and exit.
		
		if vartype(SettingsFile) <> 'C' or empty(SettingsFile)
			error cnERR_ARGUMENT_INVALID
		else
		
		* Create an MSXML DOMDocument object.
		
			try
				loDOM = createobject('MSXML2.DOMDocument.3.0')
			catch to loException
				loDOM = .NULL.
			endtry
			if vartype(loDOM) = 'O'
		
		* Create the root and other nodes.
		
				loDOM.preserveWhiteSpace = .T.
				loInstruction = loDOM.createProcessingInstruction('xml', ;
					'version="1.0" encoding="utf-8"')
				loDOM.appendChild(loInstruction)
				loRoot = loDOM.createElement('SettingsFile')
				loRoot.setAttribute('xmlns', ;
					'http://schemas.microsoft.com/VisualStudio/2004/01/settings')
				loRoot.setAttribute('CurrentProfile', '(Default)')
				loRoot.setAttribute('GeneratedClassNamespace', '')
				loRoot.setAttribute('GeneratedClassName', 'Settings')
				loDOM.appendChild(loRoot)
				loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9))
				loRoot.appendChild(loBlank)
				loProfiles = loDOM.createElement('Profiles')
				loRoot.appendChild(loProfiles)
				loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9))
				loRoot.appendChild(loBlank)
				loSettings = loDOM.createElement('Settings')
				loRoot.appendChild(loSettings)
				loBlank = loDOM.createTextNode(chr(13) + chr(10))
				loRoot.appendChild(loBlank)
		
		* Create nodes for each setting.
		
				for each lcName in This.oSettings
					luValue   = evaluate('This.' + lcName)
					lcType    = vartype(luValue)
					loSetting = loDOM.createElement('Setting')
					loSetting.setAttribute('Name', lcName)
					do case
						case lcType = 'C'
							lcType  = ccSTRING
							lcValue = luValue
						case lcType = 'N' and '.' $ transform(luValue)
							lcType  = ccDOUBLE
							lcValue = transform(luValue)
						case lcType = 'N'
							lcType  = ccINTEGER
							lcValue = transform(luValue)
						case lcType = 'L'
							lcType  = ccBOOLEAN
							lcValue = iif(luValue, 'True', 'False')
						case lcType = 'Y'
							lcType  = ccCURRENCY
							lcValue = transform(luValue)
						case lcType $ 'DT'
							lcType  = ccDATETIME
							lcValue = ttoc(luValue, 3)
					endcase
					loSetting.setAttribute('Type',  lcType)
					loSetting.setAttribute('Scope', 'User')
					loValue = loDOM.createElement('Value')
					loValue.setAttribute('Profile', '(Default)')
					loValue.text = lcValue
					loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9) + ;
						chr(9) + chr(9))
					loSetting.appendChild(loBlank)
					loSetting.appendChild(loValue)
					loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9) + chr(9))
					loSetting.appendChild(loBlank)
					loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9) + chr(9))
					loSettings.appendChild(loBlank)
					loSettings.appendChild(loSetting)
				next lcName
		
		* Add some additional formatting.
		
				loBlank = loDOM.createTextNode(chr(13) + chr(10) + chr(9))
				loSettings.appendChild(loBlank)
		
		* Save the XML to the settings file.
		
				loDOM.Save(SettingsFile)
			endif vartype(loDOM) = 'O'
		endif vartype(SettingsFile) <> 'C' ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS specialdirectories AS mybase OF "my.vcx" 		&& Provides the paths to "special" Windows folders for the current user
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: desktop_access
		*m: desktop_assign
		*m: favorites_access
		*m: favorites_assign
		*m: mydocuments_access
		*m: mydocuments_assign
		*m: nethood_access
		*m: nethood_assign
		*m: printhood_access
		*m: printhood_assign
		*m: programs_access
		*m: programs_assign
		*m: startmenu_access
		*m: startmenu_assign
		*m: temp_access
		*m: temp_assign
		*p: desktop		&& The current user's Desktop folder
		*p: favorites		&& The current user's Favorites folder
		*p: mydocuments		&& The current user's MyDocuments folder
		*p: nethood		&& The current user's Network Neighbourhood folder
		*p: owsh		&& A reference to a Windows Scripting Host object
		*p: printhood		&& The current user's Printer Neighbourhood folder
		*p: programs		&& The current user's Programs folder
		*p: startmenu		&& The current user's StartMenu folder
		*p: temp		&& The current user's temporary folder
	*</DefinedPropArrayMethod>

	PROTECTED owsh
	cnamespace = My.Computer.FileSystem.SpecialFolders
	desktop = 		&& The current user's Desktop folder
	favorites = 		&& The current user's Favorites folder
	mydocuments = 		&& The current user's MyDocuments folder
	Name = "specialdirectories"
	nethood = 		&& The current user's Network Neighbourhood folder
	owsh = .NULL.		&& A reference to a Windows Scripting Host object
	printhood = 		&& The current user's Printer Neighbourhood folder
	programs = 		&& The current user's Programs folder
	startmenu = 		&& The current user's StartMenu folder
	temp = 		&& The current user's temporary folder
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="desktop" type="property" display="Desktop"/>
		<memberdata name="desktop_access" type="property" display="Desktop_Access"/>
		<memberdata name="desktop_assign" type="property" display="Desktop_Assign"/>
		<memberdata name="favorites" type="property" display="Favorites"/>
		<memberdata name="favorites_access" type="property" display="Favorites_Access"/>
		<memberdata name="favorites_assign" type="property" display="Favorites_Assign"/>
		<memberdata name="mydocuments" type="property" display="MyDocuments"/>
		<memberdata name="mydocuments_access" type="property" display="MyDocuments_Access"/>
		<memberdata name="mydocuments_assign" type="property" display="MyDocuments_Assign"/>
		<memberdata name="nethood" type="property" display="NetHood"/>
		<memberdata name="nethood_access" type="property" display="NetHood_Access"/>
		<memberdata name="nethood_assign" type="property" display="NetHood_Assign"/>
		<memberdata name="printhood" type="property" display="PrintHood"/>
		<memberdata name="printhood_access" type="property" display="PrintHood_Access"/>
		<memberdata name="printhood_assign" type="property" display="PrintHood_Assign"/>
		<memberdata name="programs" type="property" display="Programs"/>
		<memberdata name="programs_access" type="property" display="Programs_Access"/>
		<memberdata name="programs_assign" type="property" display="Programs_Assign"/>
		<memberdata name="startmenu" type="property" display="StartMenu"/>
		<memberdata name="startmenu_access" type="property" display="StartMenu_Access"/>
		<memberdata name="startmenu_assign" type="property" display="StartMenu_Assign"/>
		<memberdata name="temp" type="property" display="Temp"/>
		<memberdata name="temp_access" type="property" display="Temp_Access"/>
		<memberdata name="temp_assign" type="property" display="Temp_Assign"/>
		<memberdata name="owsh" type="property" display="oWSH"/>
		</VFPData>
	
	PROCEDURE desktop_access
		with This
			if empty(.Desktop)
				.Desktop = .oWSH.SpecialFolders('Desktop')
			endif empty(.Desktop)
		endwith
		return This.Desktop
		
	ENDPROC

	PROCEDURE desktop_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.Desktop = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'Desktop'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oWSH = .NULL.
		
	ENDPROC

	PROCEDURE favorites_access
		with This
			if empty(.Favorites)
				.Favorites = .oWSH.SpecialFolders('Favorites')
			endif empty(.Favorites)
		endwith
		return This.Favorites
		
	ENDPROC

	PROCEDURE favorites_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.Favorites = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'Favorites'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE Init
		* Create instances of the Windows Script Host and File System Object.
		
		This.oWSH = createobject('WScript.Shell')
		dodefault()
		
	ENDPROC

	PROCEDURE mydocuments_access
		with This
			if empty(.MyDocuments)
				.MyDocuments = .oWSH.SpecialFolders('MyDocuments')
			endif empty(.MyDocuments)
		endwith
		return This.MyDocuments
		
	ENDPROC

	PROCEDURE mydocuments_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.MyDocuments = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'MyDocuments'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE nethood_access
		with This
			if empty(.NetHood)
				.NetHood = .oWSH.SpecialFolders('NetHood')
			endif empty(.NetHood)
		endwith
		return This.NetHood
		
	ENDPROC

	PROCEDURE nethood_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.NetHood = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'NetHood'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE printhood_access
		with This
			if empty(.PrintHood)
				.PrintHood = .oWSH.SpecialFolders('PrintHood')
			endif empty(.PrintHood)
		endwith
		return This.PrintHood
		
	ENDPROC

	PROCEDURE printhood_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.PrintHood = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'PrintHood'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE programs_access
		with This
			if empty(.Programs)
				.Programs = .oWSH.SpecialFolders('Programs')
			endif empty(.Programs)
		endwith
		return This.Programs
		
	ENDPROC

	PROCEDURE programs_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.Programs = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'Programs'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE startmenu_access
		with This
			if empty(.StartMenu)
				.StartMenu = .oWSH.SpecialFolders('StartMenu')
			endif empty(.StartMenu)
		endwith
		return This.StartMenu
		
	ENDPROC

	PROCEDURE startmenu_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.StartMenu = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'StartMenu'
		endif This.CalledFromThisClass()
		
	ENDPROC

	PROCEDURE temp_access
		local lcPath, ;
			lnLength, ;
			lcBuffer
		with This
			if empty(.Temp)
				declare integer GetLongPathName in Win32API ;
					string @lpszShortPath, string @lpszLongPath, integer cchBuffer
				lcPath   = sys(2023) + ccNULL
				lnLength = 260
				lcBuffer = space(lnLength)
				GetLongPathName(@lcPath, @lcBuffer, lnLength)
				.Temp = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
			endif empty(.Temp)
		endwith
		return This.Temp
		
	ENDPROC

	PROCEDURE temp_assign
		* Save the value if we're doing so from this class. Otherwise, throw a
		* "property is read-only" error.
		
		lparameters tcValue
		if This.CalledFromThisClass()
			This.Temp = tcValue
		else
			error cnERR_PROPERTY_READ_ONLY, 'Temp'
		endif This.CalledFromThisClass()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS user AS mybase OF "my.vcx" 		&& Provides information about the current user
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: displayname_access
		*m: displayname_assign
		*m: getaduser		&& Returns an Active Directory user object for the current Windows user
		*m: userdomain_access
		*m: userdomain_assign
		*m: username_access
		*m: username_assign
		*p: displayname		&& The display name for the current user
		*p: oaduser		&& A reference to an Active Directory user object
		*p: owsh		&& A reference to a Windows Scripting Host object
		*p: userdomain		&& The domain for the current Windows user
		*p: username		&& The name of the current Windows user
	*</DefinedPropArrayMethod>

	PROTECTED oaduser,owsh
	cnamespace = My.User
	displayname = 		&& The display name for the current user
	Name = "user"
	oaduser = .NULL.		&& A reference to an Active Directory user object
	owsh = .NULL.		&& A reference to a Windows Scripting Host object
	userdomain = 		&& The domain for the current Windows user
	username = 		&& The name of the current Windows user
	_memberdata = <VFPData>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="addmembers" type="method" display="AddMembers"/>
		<memberdata name="cnamespace" type="property" display="cNameSpace"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="warning" type="method" display="Warning"/>
		<memberdata name="ccaption" type="property" display="cCaption"/>
		<memberdata name="errormessage" type="property" display="ErrorMessage"/>
		<memberdata name="quietmode" type="property" display="QuietMode"/>
		<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		<memberdata name="username" type="property" display="UserName"/>
		<memberdata name="username_access" type="property" display="UserName_Access"/>
		<memberdata name="username_assign" type="property" display="UserName_Assign"/>
		<memberdata name="owsh" type="property" display="oWSH"/>
		<memberdata name="userdomain" type="property" display="UserDomain"/>
		<memberdata name="userdomain_access" type="property" display="UserDomain_Access"/>
		<memberdata name="userdomain_assign" type="property" display="UserDomain_Assign"/>
		<memberdata name="displayname" type="property" display="DisplayName"/>
		<memberdata name="displayname_access" type="property" display="DisplayName_Access"/>
		<memberdata name="displayname_assign" type="property" display="DisplayName_Assign"/>
		<memberdata name="getaduser" type="method" display="GetADUser"/>
		<memberdata name="oaduser" type="property" display="oADUser"/>
		</VFPData>
	
	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oWSH    = .NULL.
		This.oADUser = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE displayname_access
		local lcReturn
		if vartype(This.oADUser) = 'O'
			lcReturn = This.oADUser.DisplayName
		else
			lcReturn = ''
		endif vartype(This.oADUser) = 'O'
		return lcReturn
		
	ENDPROC

	PROCEDURE displayname_assign
		* Throw a "property is read-only" error.
		
		lparameters tcValue
		error cnERR_PROPERTY_READ_ONLY, 'DisplayName'
		
	ENDPROC

	PROTECTED PROCEDURE getaduser		&& Returns an Active Directory user object for the current Windows user
		* This code was adapted from code posted by Sergey Berezniker on the Universal
		* Thread.
		
		local loNameTrans, ;
			lcDN, ;
			loADUser
		#define cnADS_NAME_INITTYPE_GC 3
		#define cnADS_NAME_TYPE_NT4    3
		#define cnADS_NAME_TYPE_1779   1
		try
			loNameTrans = createobject('NameTranslate')
			loNameTrans.Init(cnADS_NAME_INITTYPE_GC, '')
			loNameTrans.Set(cnADS_NAME_TYPE_NT4, This.UserDomain + '\' + This.UserName)
			lcDN     = loNameTrans.Get(cnADS_NAME_TYPE_1779)
			loADUser = getobject('LDAP://' + lcDN)
		catch to loException when loException.Errorno = 1426
			loADUser = .NULL.
		endtry
		return loADUser
		
	ENDPROC

	PROCEDURE Init
		* Create a Windows Script Host object and get an Active Directory user object
		* for the current Windows user.
		
		with This
			.oWSH    = createobject('WScript.Network')
			.oADUser = .GetADUser()
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE userdomain_access
		return This.oWSH.UserDomain
		
	ENDPROC

	PROCEDURE userdomain_assign
		* Throw a "property is read-only" error.
		
		lparameters tcValue
		error cnERR_PROPERTY_READ_ONLY, 'UserDomain'
		
	ENDPROC

	PROCEDURE username_access
		return This.oWSH.UserName
		
	ENDPROC

	PROCEDURE username_assign
		* Throw a "property is read-only" error.
		
		lparameters tcValue
		error cnERR_PROPERTY_READ_ONLY, 'UserName'
		
	ENDPROC

ENDDEFINE
